<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[远程通知推送教程]]></title>
      <url>http://jmstack.github.io/2016/05/11/%E8%BF%9C%E7%A8%8B%E9%80%9A%E7%9F%A5%E6%8E%A8%E9%80%81%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>版权声明</strong> 本文翻译自:<a href="https://www.raywenderlich.com/123862/push-notifications-tutorial" target="_blank" rel="external">raywenderlich.com</a> 原文作者: <a href="https://twitter.com/JackTripleU" target="_blank" rel="external">Jack Wu</a> 译者: <a href="http://lemtter.com" target="_blank" rel="external">JMStack</a> 转载请说明原文及译文出处.</p>
</blockquote>
<p>iOS开发者们喜欢想象他的用户们会每时每刻使用他们所开发的APP,但是残酷的事实是他们的用户会有关闭APP来处理其它事情的时候.就像你洗好的衣服总要人去叠吧.</p>
<p>幸好,推送通知功能可以让开发者与用户建立连接并进行简单的交互即使用户当前并没有使用APP!</p>
<p>从推送通知功能第一次问世到现在已经变得越来越强大.在iOS9上,远程推送可以做到:</p>
<ul>
<li>显示短文本</li>
<li>播放通知提示音</li>
<li>设置APP图标的角标</li>
<li>在不打开APP的情况下,允许用户与APP交互</li>
<li>允许APP在后台静默唤醒来执行任务</li>
</ul>
<p>这份远程推送通知教程会告诉你远程推送的工作原理的并让你了解它的一些特性.</p>
<p>在开始推送测试之前你需要具备以下条件:</p>
<ul>
<li><strong>一台iOS设备</strong>.远程推送不能在摸拟器上运行,所以你需要一台真机.</li>
<li><strong>一个开发者帐号</strong> 从Xcode7开始,在真机上测试APP不再需要加入开发者计划.但是为了配置远程推送,你需要有一个与APP ID对应的推送证书,获得这个证书你需要加开发者计划.</li>
</ul>
<a id="more"></a>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>为了接收发送远程推送通知你必须完成以下3个主要的任务:</p>
<ol>
<li>App必须正确配置并注册APNS(Apple Push Notification Service),以便所有设置都完成时就能马上接收到通知</li>
<li>服务端必须向APNS发送一条明确指向一个或多个设备的通知</li>
<li>App必需接收服务端发送的通知;App可以执行通知包含的任务或者在application的代理(delegate)回调方法内处理用户交互行为.</li>
</ol>
<p>任务1和任务3是这份推送通知教程主要关注的内容,因为这两个任务是iOS开发者的工作.</p>
<p>任务2也会在这份教程中简略的提及,并且多数情况仅仅是为了测试目的.发送一个远程通知是App服务端的工作,并且这部分内部会因为App的不同而不同.大多数App都会使用第三方服务(比如Parse.com或者Google ColoudMessaging)推送通知,其它的App或使用定制化的解决方案或使用比较流行的框架(比如: Houston).</p>
<p>正式开始之,下载已经准备好的 <strong>WenderCast</strong> <a href="https://cdn5.raywenderlich.com/wp-content/uploads/2016/03/WenderCast-Starter-1.1.zip" target="_blank" rel="external">开始工程</a>.WenderCast是一个让用户获取raywenderlich.com播客节目和时实消息的应用.</p>
<p>在Xcode中打开WenderCast.xcodeproj简单浏览一下.编绎运行即可查看当前最新播客节目:<br><img src="http://o6jvfp7kw.bkt.clouddn.com/BuildAndRun1.png" alt="BuildAndRun1"><br>这个App的存在的问题是当有新的播客节目可以获取时不能通知到用户.并且也不能显示任何最新的消息.接下来你将用远程推送功能修复这个问题!</p>
<h1 id="为App配置远程推送功能"><a href="#为App配置远程推送功能" class="headerlink" title="为App配置远程推送功能"></a>为App配置远程推送功能</h1><p>推送通知需要较高的安全性.这点是非常重要的,因为你不会想让其它人给你的用户发送通知.这也就意味着要实现远程推送功能你必需跳过一些坑.</p>
<h2 id="打开远程推送服务"><a href="#打开远程推送服务" class="headerlink" title="打开远程推送服务"></a>打开远程推送服务</h2><p>第一步是更改App ID.在Xcode中进入 <strong>App Settings -&gt; General</strong> 把 <strong>Bundle Identifier</strong> 改为任意唯一的字符串.<br><img src="http://o6jvfp7kw.bkt.clouddn.com/ChangeBundleID.png" alt="ChangeBundleID"><br>接下来你需要在你的开发者帐号下添加打开了推送通知功能的App ID.幸运的是,Xcode有更简单的方法实现这个步骤.进入 <strong>App Settings -&gt; Capabilities</strong> 把Push Notifications设置为 <strong>On</strong>.<br>在Xcode完成一些下载后,看起应该会是下面的样子<br><img src="http://o6jvfp7kw.bkt.clouddn.com/PushNotificaitonCapability.png" alt="PushNotificaitonCapability"><br>这个步骤背后的操作是: 如果你当前的开发者帐号下没有对应的App ID就会主动创建App ID,并且打开推送通知功能.你可以登陆开发者中心确认是否打开了这个功能:<br><img src="http://o6jvfp7kw.bkt.clouddn.com/blog/%E8%BF%9C%E7%A8%8B%E9%80%9A%E7%9F%A5%E6%8E%A8%E9%80%81%E6%95%99%E7%A8%8B/MemberCenter1.png" alt="MemberCenter1"></p>
<p>如果这个过程中出现问题,可以手动创建App ID或者点击开发者中心 <strong>+</strong> 或 <strong>Edit</strong> 按钮开启推送通知功能.</p>
<p>以上就是你目前需要的配置.</p>
<h2 id="注册远程推送"><a href="#注册远程推送" class="headerlink" title="注册远程推送"></a>注册远程推送</h2><p>注册远程推送需要两步.第一步,你必需向用户请求推送通知许可,获得许可之后才能注册远程推送.如果所有步骤进行顺利,系统将会向你提供一个 <strong>device token</strong> ,你可以把它认为是当前设备的”地址”.</p>
<p>在WenderCast应用中你需要用在应用启动后立即注册远程推送.</p>
<p>打开AppDelegate.swift,添加以下代码到AppDelegate末尾.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func registerForPushNotifications(application: UIApplication) &#123;</span><br><span class="line">  let notificationSettings = UIUserNotificationSettings(</span><br><span class="line">    forTypes: [.Badge, .Sound, .Alert], categories: nil)</span><br><span class="line">  application.registerUserNotificationSettings(notificationSettings)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法创建了一个 <em>UIUserNotificationSettings</em> 实例对象并把它作为参数传给 <em>registerUserNotificationSettings(_:)</em> .</p>
<p><em>UIUserNotificationSettings</em> 存储你的应用将到用到的通知类型设置.对于UIUserNotificationType的值你可以用下面几个枚举值的任意组合.</p>
<ul>
<li>.Badge 允许App在图标上显示角标数字</li>
<li>.Sound 允许App播放声音</li>
<li>.Alert 允许App显示文本</li>
</ul>
<p><em>UIUserNotificationCategory</em> 是Set类型参数当前暂时传 <em>nil</em>,以允许你指定你的App能够处理的不同类型的通知.当你需要实现可交互的通知时,这样的设置是必需的.后面的部分你将会用到可交互通知.</p>
<p>在 <em>application(_:didFinishLaunchingWithOptions:launchOptions:):</em> 方法内的第一行调用 <em>registerForPushNotifications(_:)</em> :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool &#123;</span><br><span class="line">  registerForPushNotifications(application)</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编绎运行.当App启动时你会收到一个弹窗请求通知许可:<br><img src="http://o6jvfp7kw.bkt.clouddn.com/BuildAndRun2.png" alt="BuildAndRun2.png"></p>
<p>点击 <strong>OK</strong> ,现在App可以显示通知了.但是,如果用户拒绝了发送通知的请求该应怎么办?</p>
<p>当用户接受或拒绝请求许可又或者之前做出过是否允许的选择, <em>UIApplicationDelegate</em> 的一个代理方法将会被调用. 添加以下代码到 <em>AppDelegate</em> :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func application(application: UIApplication, didRegisterUserNotificationSettings notificationSettings: UIUserNotificationSettings) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个方法中,你会接收到另一个 <em>UIUserNotificationSettings</em> 实现对象.这个实例对象与之前你之前所传入的不同.你之前传入的是你所希望的设置,而当前这个是用户当前授权的设置.</p>
<p>在App每次启动时都调用 <em>registerUserNotificationSettings(_:)</em> 是相当重要的.因为用户在任何时候都有可能在设置应用内改变通知的授权许可. <em>application(_:didRegisterUserNotificationSettings:)</em> 方法会告诉你用户当前给你的App什么样的授权许可.</p>
<p>现在第一步已经完成,你可以注册远程推送通知了.这一步相当简单,因为你不再需要向用户请求什么许可了.用下面的代码更新 <em>application(_:didRegisterUserNotificationSettings:)</em> 方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func application(application: UIApplication, didRegisterUserNotificationSettings notificationSettings: UIUserNotificationSettings) &#123;</span><br><span class="line">  if notificationSettings.types != .None &#123;</span><br><span class="line">    application.registerForRemoteNotifications()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的方法中,首先检查当前用户是否允许通知,如果允许直接调用 <em>registerForRemoteNotifications()</em>.</p>
<p>其次, <em>registerForRemoteNotifications()</em> 的请求注册的返回状态会通过 UIApplicationDelegate协议中的某些方法通知你.</p>
<p>添加以下代码到 <em>AppDelegate</em> :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func application(application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: NSData) &#123;</span><br><span class="line">  let tokenChars = UnsafePointer&lt;CChar&gt;(deviceToken.bytes)</span><br><span class="line">  var tokenString = &quot;&quot;</span><br><span class="line"></span><br><span class="line">  for i in 0..&lt;deviceToken.length &#123;</span><br><span class="line">    tokenString += String(format: &quot;%02.2hhx&quot;, arguments: [tokenChars[i]])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  print(&quot;Device Token:&quot;, tokenString)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func application(application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: NSError) &#123;</span><br><span class="line">  print(&quot;Failed to register:&quot;, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就像方法名所暗示的那样,当注册通知成功后系统会调用 <em>application(_:didRegisterForRemoteNotificationsWithDeviceToken:)</em> 方法,否则将会调用 <em>application(_:didFailToRegisterForRemoteNotificationsWithError:).</em> 方法.</p>
<p>当前 <em>application(_:didRegisterForRemoteNotificationsWithDeviceToken:)</em> 方法的实现看起来难以理解,其实它仅仅只是获取 <em>deviceToken</em> 然后转换成字符串.deviceToken的值就是这个过程得到的结果.它是由APNs服务器提供用来标识当前设备当前App.当发送时推送通知的时候,App用deviceToken作为”地址”传递到当前设备.</p>
<blockquote>
<p><strong>注意</strong> 会有很多原因导致注册失败.最常碰到原因是程序运行在模拟器上,或者App ID设置不正确.具体原因打印error值会提供更加详细的信息.</p>
</blockquote>
<p>到此,编绎运行.确保你当前运行在真机上,你将会在控制台看到打印出的device token.下面将会是你看到的结果:<br><img src="http://o6jvfp7kw.bkt.clouddn.com/DeviceToken.png" alt="DeviceToken"></p>
<p>把device token复制到某处保存.</p>
<p>在正式发送通知之前你还需要一点点配置,所以回到开发者中心.</p>
<h2 id="创建一个SSL证书和PEM文件"><a href="#创建一个SSL证书和PEM文件" class="headerlink" title="创建一个SSL证书和PEM文件"></a>创建一个SSL证书和PEM文件</h2><p>在开发者中心进入 <strong>Certificates, Identifiers &amp; Profiles -&gt; Identifiers -&gt; App IDs</strong> 找到你应用的App ID.在 <strong>Application Services</strong> 下面 <strong>Push Notifications</strong> 应该为 <strong>Configurable</strong> :<br><img src="http://o6jvfp7kw.bkt.clouddn.com/ConfigurablePushNotifications.png" alt="ConfigurablePushNotifications"><br>点击 <strong>Edit</strong> 滚动到 <strong>Push Notifications</strong> :<br><img src="http://o6jvfp7kw.bkt.clouddn.com/CreateCertificate.png" alt="CreateCertificate"><br>在 <strong>Development SSL Certificate</strong> 栏下,点击 <strong>Create Certificate…</strong> 接下来的步骤就是创建 <strong>CSR</strong> 文件.创建好CSR文件后点击 <strong>continue</strong> 和 <strong>Generate</strong>,这步会用你创建的CSR文件生成证书.最后下载并运行生成好的证书,证书将被添加到你的钥匙串应用中,并与私钥成对.<br><img src="http://o6jvfp7kw.bkt.clouddn.com/KeychainCertificate.png" alt="KeychainCertificate"></p>
<p>在开发者中心,你的App ID现在推送通知功能在development下应该处于Enable状态.<br><img src="http://o6jvfp7kw.bkt.clouddn.com/PushNotificationEnabled.png" alt="PushNotificationEnabled"></p>
<p>在关闭钥匙串应用前还有最后一件事,右击你刚才添加的证书,选择 <strong>Export</strong> :<br><img src="http://o6jvfp7kw.bkt.clouddn.com/ExportCertificate.png" alt="ExportCertificate"></p>
<p>保存在桌面并命名为WenderCastPush.p12.<br><img src="http://o6jvfp7kw.bkt.clouddn.com/SaveP12.png" alt="SaveP12"></p>
<p>你会被提示要求为你的.p12文件设置密码,你可以选择不输或者输入一个你想设置的密码.这里我用”WenderCastPush”作为密码.接下来你需要输入电脑登陆密码来允许导出p12文件.</p>
<p>接下来,打开你的终端并执行以下命令来从p12文件生成PEM文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/Desktop</span><br><span class="line">$ openssl pkcs12 -in WenderCastPush.p12 -out WenderCastPush.pem -nodes -clcerts</span><br></pre></td></tr></table></figure></p>
<p>如果你导出p12文件时输入了密码,在这里你必须输入相同的密码.</p>
<p>到此为止,你已经艰难的跃过了很多坑,这一切都是值得的.接下来你将用你生成的WenderCastPush.pem文件发送第一个通知.</p>
<h1 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h1><p>之前下载的<a href="https://cdn5.raywenderlich.com/wp-content/uploads/2016/03/WenderCast-Starter-1.1.zip" target="_blank" rel="external">开始工程</a>会包含一个WenderCastPush文件;里面包含两个用于发送通知简单脚本.你需要用到的是newspush.php.正如文件名所暗示的,这个脚本将会向你的用户发送一个弹窗通知消息.</p>
<p>发送推送通知需要和APNS建立SSL连接,SSL连接是用之前创建的证书进行加密.这就是为什么要生成 <strong>WenderCastPush.pem</strong> 文件.重命名 <strong>WenderCastPush.pem</strong> 为 <strong>ck.pem</strong>,并且替换掉当前已经存在于 <strong>WenderCastPush</strong> 文件夹下的 <strong>ck.pem</strong> 文件.</p>
<p>打开 <strong>newspush.php</strong> 并更新之前接收到的 <strong>$deviceToken</strong> 和导出文件时输入的密码 <strong>$passphrase</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Put your device token here (without spaces):</span><br><span class="line">$deviceToken = &apos;43e798c31a282d129a34d84472bbdd7632562ff0732b58a85a27c5d9fdf59b69&apos;;</span><br><span class="line"></span><br><span class="line">// Put your private key&apos;s passphrase here:</span><br><span class="line">$passphrase = &apos;WenderCastPush&apos;;</span><br></pre></td></tr></table></figure></p>
<p>打开终端, <strong>cd</strong> 到 <strong>newspush.php</strong> 所在的文件夹,输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ush.php &apos;Breaking News&apos; &apos;https://raywenderlich.com&apos;</span><br></pre></td></tr></table></figure></p>
<p>如果进行顺利,你的终端将会显示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connected to APNS</span><br><span class="line">Message successfully delivered</span><br></pre></td></tr></table></figure></p>
<p>现在,你应该会收到你的第一条通知:<br><img src="http://o6jvfp7kw.bkt.clouddn.com/FirstPush-281x500.png" alt="FirstPush-281x500"></p>
<blockquote>
<p><strong>注意</strong> 如果你的App被打开并处于前台运行状态,你将看不到任何东西.通知已经被投送但是App还不会处理这个通知.你只需要简单的关闭App并重新发送通知即可.</p>
</blockquote>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>也许你会遇到以下问题:</p>
<p><strong>只能接收到部分通知</strong>:如果你同时发送多个通知,只有部分通知将会被接收,不用担心!这正是我们想要的结果.当发送通知时APNS会为每一个开启了推送通知的设备保持一个高质量服务(Quality of Service)队列.这个队列的大小是1,所以如果你同时发送多个通知,最后一个通知才会被发送.</p>
<p><strong>连接到APNS出现问题</strong>:出现这个问题的原因可能是你的防火墙阻塞了APNS所使用的端口.所以确保你的防火墙没有阻塞住这些端口.另一个可能的原因是私钥和CSR文件不正确.记住,每一个App ID有一个唯一的CSR和配对的私钥.</p>
<h1 id="解剖推送通知的基本原理"><a href="#解剖推送通知的基本原理" class="headerlink" title="解剖推送通知的基本原理"></a>解剖推送通知的基本原理</h1><p>在进行任务3之前,需要理解一下你推送的通知,打开 <strong>newspush.php</strong> 文件理解发送一个通知的基本概念应该是怎么样的.</p>
<p>注意第32-40行,这就是用JSON格式编码的装载体.这就是实际上发送给APNS的东西.在我们当前的例子中,装载体像下面一样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;aps&quot;:</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;alert&quot;: &quot;Breaking News!&quot;,</span><br><span class="line">    &quot;sound&quot;: &quot;default&quot;</span><br><span class="line">    &quot;link_url&quot; : &quot;https://raywenderlich.com,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于一个不懂JSON数据的人来说,用{}括起来的块相当于一个字典类型的数据.</p>
<p>这个装载体是一个至少包含一项内容的字典,这项内容就是 <strong>aps</strong>, 它本身也是一个字典.在这个例子中”aps”包含”alert”,”sound”和”link_url”等字段.当接收到一个通知,就会显示一个包含”Breaking News!”文本的提醒视图,并且有标准的提醒音效.</p>
<p>“link_url”实际上是一个自定义的字段.你可以添加类似的自定义字段到装载体中,并且它会被投送到你的应用.因为你并没有在应用中处理这个字段,所以当前接收到这个键值对会什么都不做.</p>
<p>你可以在aps字典中添加以下5个键(key):</p>
<ul>
<li><p>alert. 这个字段可以是一个字符串,就像当前的例子.或是是一个字典.如果是一个字典,可以是本地化的文本或者通知的其它部分.查看<a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/TheNotificationPayload.html#//apple_ref/doc/uid/TP40008194-CH107-SW1" target="_blank" rel="external">苹果文档</a>所支持的key.</p>
</li>
<li><p>badge. 这是一个将被显示在应用图标上的数字.你可以设置这个键为0来清除角标.</p>
</li>
<li><p>sound. 通过设置这个建,你可以播放存放在App本地定制的通知提示音来取代系统默认的通知提示音.定制的通知提示音必须在30秒以内并且还有一些其它的限制,你可以查看<a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/IPhoneOSClientImp.html#//apple_ref/doc/uid/TP40008194-CH103-SW6" target="_blank" rel="external">苹果文档</a>了解更详细信息.</p>
</li>
<li><p>content-available.设置这个键为1,当前通知会变成静默通知.这个部分会在这份教程的后面部分探索.</p>
</li>
<li><p>category. 这个键定义了通知的分类,用于显示定制通知所包含的交互行为.同样,接下来会探索这部分的内容.</p>
</li>
</ul>
<p>除此之外,你可以添加任意你想要添加的定制化数据,只要装载体不超过4096个字节.</p>
<p>如果你玩够了推送通知,接下来我们进入到下一个章节.</p>
<h1 id="处理接收到的通知"><a href="#处理接收到的通知" class="headerlink" title="处理接收到的通知"></a>处理接收到的通知</h1><p>在这个章节,你将会学习当App接收到通知后或者用户点击了通知应该如何执行什么样的操作.</p>
<h2 id="当你接收到一个通知后会发生什么"><a href="#当你接收到一个通知后会发生什么" class="headerlink" title="当你接收到一个通知后会发生什么"></a>当你接收到一个通知后会发生什么</h2><p>当你的App接收到一个通知, <em>UIApplicationDelegate</em> 的一个方法将会被调用.<br>需要根据接到收通知时App所处的状态的进行不同的处理.</p>
<ul>
<li><p>如果你的应用当前不在运行,并且用户通过点击推送通知启动应用,通知内容会通过 <em>application(_:didFinishLaunchingWithOptions:)</em> 方法的 <em>launchOptions</em> 参数进行传递.</p>
</li>
<li><p>如果你应用当前正运行在前台,推送通知将不会被显示.但是 <em>application(_:didReceiveRemoteNotification:)</em> 会被立即调用.</p>
</li>
<li><p>如果你的应用正在运行,或者被挂起在后台,并且用户通过点击通知使应用进入前台 <em>application(_:didReceiveRemoteNotification:)</em> 方法会被调用.</p>
</li>
</ul>
<p>在第一种情况下, WenderCast将到创建一个新的section,并直接打开以显示到这个新建section.添加以下代码到 <em>application(_:didFinishLaunchingWithOptions:)</em> 的末尾return语句之前.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Check if launched from notification</span><br><span class="line">// 1</span><br><span class="line">if let notification = launchOptions?[UIApplicationLaunchOptionsRemoteNotificationKey] as? [String: AnyObject] &#123;</span><br><span class="line">  // 2</span><br><span class="line">  let aps = notification[&quot;aps&quot;] as! [String: AnyObject]</span><br><span class="line">  createNewNewsItem(aps)</span><br><span class="line">  // 3</span><br><span class="line">  (window?.rootViewController as? UITabBarController)?.selectedIndex = 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码做了以下3件事:</p>
<ol>
<li><p>检查 <em>UIApplicationLaunchOptionsRemoteNotificationKey</em> 键对应的值是否存在,如果存在,这个值应该就是你发送的通知装载体.</p>
</li>
<li><p>如果存在,获取 <em>aps</em> 对应字典并传给 <em>createNewNewsItem(_:)</em> 方法,这个方法根据接收的字典创建一个 <em>NewItem</em>,并刷新表格.</p>
</li>
<li><p>改变tab控制器当前选中的tab索引值为1,也就是直接显示新闻控制器视图.</p>
</li>
</ol>
<p>为了测试这部分代码,你需要编辑WenderCast的scheme:<br><img src="http://o6jvfp7kw.bkt.clouddn.com/EditScheme.png" alt="EditScheme"></p>
<p>在 <strong>Run -&gt; Info</strong> 下选择 <strong>Wait for executable to be launched</strong>:<br><img src="http://o6jvfp7kw.bkt.clouddn.com/WaitForLaunch.png" alt="WaitForLaunch"></p>
<p>这个选项会使调试器等待应用程序安装直到应用程序第一次被启动。</p>
<p>编绎运行,完成安装后,发送一些新的动态.点击通知以启动App,启动之后App会显示一些新消息.<br><img src="http://o6jvfp7kw.bkt.clouddn.com/BuildAndRunFirstNews.png" alt="BuildAndRunFirstNews"></p>
<blockquote>
<p><strong>注意</strong> 如果你突然接收不到通知,最有可能的原因是device token被改了.如果你删除应用再重新安装就有可能出现这种情况. 确保你的device token是正确的.</p>
</blockquote>
<p>为了处理另外两种情况,添加以下代码到 <em>AppDelegate</em>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func application(application: UIApplication, didReceiveRemoteNotification userInfo: [NSObject : AnyObject]) &#123;</span><br><span class="line">  let aps = userInfo[&quot;aps&quot;] as! [String: AnyObject]</span><br><span class="line">  createNewNewsItem(aps)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法直接创建了一个新的 <em>NewsItem</em>. 现在你可以把scheme设置回自动启动App.</p>
<p>编绎运行.保持App运行在前台,并选中新闻页.发送一个通知,你可以看到消息奇迹般的显示在视线内.<br><img src="http://o6jvfp7kw.bkt.clouddn.com/NewNews-281x500.png" alt="NewNews-281x500"></p>
<p>就是这样!你的App现在可以处理基本的推送消息.</p>
<p>一些需要注意的事情:很多情况推送通知可能会被遗漏.对于WenderCast应用来说是没有问题的,因为装满消自己的列表对这个应用来说并不是那么重要,但是一般来讲你不应该把推送通知做为传递内容的唯一方式.作为备选项,推送通知应该仅仅只是指示当前有新的内容可以获取并让App从服务器下载这些新的内容.WenderCast应用在这方有一些局限性,因为它并没有合适的服务端.</p>
<h1 id="可交互的通知"><a href="#可交互的通知" class="headerlink" title="可交互的通知"></a>可交互的通知</h1><p>可交互的通知允许你添加定制化的按钮在通知上.你也许注意到邮件通知或者Twitter消息通知有一个让你回复或者点赞的部位.</p>
<p>可交互的通知是你通过注册通知时设置 <strong>categories</strong> 定义的.每一个通知分类都可以有多个预先自定义的交互.</p>
<p>一旦完成注册,就可以发送这个分类的通知.当接收到通知相应的交互就可以被用户获取.</p>
<p>对于 <strong>WenderCast</strong> 应用,你将定义一个自定义”View”动作的”News”分类,自定义”View”允许用户选择查看,如果用户选择就会在App中直接显示对应的消息详细文章.</p>
<p>添加以下代码到 <em>registerForPushNotifications(_:):</em> 的开头.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let viewAction = UIMutableUserNotificationAction()</span><br><span class="line">viewAction.identifier = &quot;VIEW_IDENTIFIER&quot;</span><br><span class="line">viewAction.title = &quot;View&quot;</span><br><span class="line">viewAction.activationMode = .Foreground</span><br></pre></td></tr></table></figure></p>
<p>这段代码创建了一个按钮标题名为”View”的新交互通知,当交互通知被用户触发时打开App并让其进入前台.这个交互动作的标识符是 <em>VIEW_IDENTIFIER</em> ,这个标识符被用于区分同一通知的不同交互动作.</p>
<p>添加以下人码片段至前面代码之后:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let newsCategory = UIMutableUserNotificationCategory()</span><br><span class="line">newsCategory.identifier = &quot;NEWS_CATEGORY&quot;</span><br><span class="line">newsCategory.setActions([viewAction], forContext: .Default)</span><br></pre></td></tr></table></figure></p>
<p>这段代码定义了一个新通知分类,设置交互动作为之前定义的”View”动作,设置标识符为” NEWS_CATEGORY”,这个标识符你是装载体要包含的内容以用其指示当前通知属于哪个分类.</p>
<p>最后,通过以下代码,把新建分类传递给UIUserNotificationSettings构造方法.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let notificationSettings = UIUserNotificationSettings(forTypes: [.Badge, .Sound, .Alert], categories: [newsCategory])</span><br></pre></td></tr></table></figure></p>
<p>编绎运行,应用会注册新通知设定.按Home键来退出当前应用,以使推送通知能够显示.</p>
<p>在你再次运行 <em>newspush.php</em> 之前,首先对指定的分类做一个改动.打开 <em>newspush.php</em> 修改通知装载体使它包含通知的分类标识符:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$body[&apos;aps&apos;] = array(</span><br><span class="line">  &apos;alert&apos; =&gt; $message,</span><br><span class="line">  &apos;sound&apos; =&gt; &apos;default&apos;,</span><br><span class="line">  &apos;link_url&apos; =&gt; $url,</span><br><span class="line">  &apos;category&apos; =&gt; &apos;NEWS_CATEGORY&apos;,</span><br><span class="line">  );</span><br></pre></td></tr></table></figure></p>
<p>保存并关闭newspush.php,然后运行以发送通知.如果一切进展顺利,你可以下拉并轻扫显示的通知你会看到View按钮被显示.<br><img src="http://o6jvfp7kw.bkt.clouddn.com/ViewAction-281x500.png" alt="ViewAction-281x500"><br>非常好,点击”View”按钮将启动WenderCast但不会做任何事情.为了获取通知装载体显示新的内容项,你需要在代理方法中做更多的操作.</p>
<h2 id="处理通知交互动作事件"><a href="#处理通知交互动作事件" class="headerlink" title="处理通知交互动作事件"></a>处理通知交互动作事件</h2><p>回到 <strong>AppDelegate.swift</strong>,添加另一个方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func application(application: UIApplication, handleActionWithIdentifier identifier: String?, forRemoteNotification userInfo: [NSObject : AnyObject], completionHandler: () -&gt; Void) &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let aps = userInfo[&quot;aps&quot;] as! [String: AnyObject]</span><br><span class="line"></span><br><span class="line">  // 2</span><br><span class="line">  if let newsItem = createNewNewsItem(aps) &#123;</span><br><span class="line">    (window?.rootViewController as? UITabBarController)?.selectedIndex = 1</span><br><span class="line"></span><br><span class="line">    // 3</span><br><span class="line">    if identifier == &quot;VIEW_IDENTIFIER&quot;, let url = NSURL(string: newsItem.link) &#123;</span><br><span class="line">      let safari = SFSafariViewController(URL: url)</span><br><span class="line">      window?.rootViewController?.presentViewController(safari, animated: true, completion: nil)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 4</span><br><span class="line">  completionHandler()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当用户通过通知的交互动作打开应用时这个方法将会被调用.这看来起好像做了很多事,但是实际上没有多少新的东西.这段代码做了以下事情:</p>
<ul>
<li>获取 <em>aps</em> 字典</li>
<li>根据获取到的字典创建 <em>NewItem</em> 并跳到新闻页.</li>
<li>检查以 <em>identifier</em> 为参数传进来的交互动作的标识符.如果View交互动作的标识符和链接有效则用 <em>SFSafariViewController</em> 显示这个链接内容.</li>
<li>在处理完用户交互动用之后调用系统传递给你的 <em>completionHandler</em> 回调.</li>
</ul>
<p>编绎运行,退出App,发送通知.但请确保下面的URL中有效的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ php newspush.php &apos;New Posts!&apos; &apos;https://raywenderlich.com&apos;</span><br></pre></td></tr></table></figure></p>
<p>点击通知的交互动作,在WenderCast应用启动后会立即展示Safari控制器.<br><img src="http://o6jvfp7kw.bkt.clouddn.com/SafariVC-281x500.png" alt="SafariVC-281x500"></p>
<p>恭喜,你刚刚已经完成了可交互通知的实现!尝试多发送几次通知,并用不同的方法打开通知观察通知的展现行为.</p>
<h1 id="静默推送通知"><a href="#静默推送通知" class="headerlink" title="静默推送通知"></a>静默推送通知</h1><p>静默推送通知可以静默方式的唤醒你的App并让它在后台执行任务.WenderCast可以利用这个特性悄悄地刷新播客列表.</p>
<p>正如你所想象的,配合合适的服务端这个功能会非常有用.你不需要不断的主动获取数据,当有数据可获取时仅仅只需要发送一个静默通知.</p>
<p>开始之前进入 <strong>App Settings -&gt; Capabilites</strong> 并打开 WenderCast的 <strong>Background Modes</strong>. 检查最后一个选项, <strong>Remote Notifications</strong> 是否勾选.<br><img src="http://o6jvfp7kw.bkt.clouddn.com/BackgroundModes.png" alt="BackgroundModes"></p>
<p>现在你的App接收到某个静默通知就可以在后台唤醒.</p>
<p>在AppDelegate内,用下面更强大的版本替换 <em>application(_:didReceiveRemoteNotification:)</em> 方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func application(application: UIApplication, didReceiveRemoteNotification userInfo: [NSObject : AnyObject], fetchCompletionHandler completionHandler: (UIBackgroundFetchResult) -&gt; Void) &#123;</span><br><span class="line">  let aps = userInfo[&quot;aps&quot;] as! [String: AnyObject]</span><br><span class="line"></span><br><span class="line">  // 1</span><br><span class="line">  if (aps[&quot;content-available&quot;] as? NSString)?.integerValue == 1 &#123;</span><br><span class="line">    // Refresh Podcast</span><br><span class="line">    // 2</span><br><span class="line">    let podcastStore = PodcastStore.sharedStore</span><br><span class="line">    podcastStore.refreshItems &#123; didLoadNewItems in</span><br><span class="line">      // 3</span><br><span class="line">      completionHandler(didLoadNewItems ? .NewData : .NoData)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else  &#123;</span><br><span class="line">    // News</span><br><span class="line">    // 4</span><br><span class="line">    createNewNewsItem(aps)</span><br><span class="line">    completionHandler(.NewData)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码:</p>
<ol>
<li>检查 <em>content-available</em> 是否为1,以确定是否是静默推送.</li>
<li>刷新播客列表,因为需要访问网络所以刷新列表是异步的.</li>
<li>当刷新完列表,调用 <em>completionHandler</em> 回调方法,让系统知道数据是否已经下载.</li>
<li>如果不是静默通知,假定它是消息并创建一个新的消息项.</li>
</ol>
<p>必需要确保 <em>completionHandler(_:)</em> 方法被调用并传递真实的是否获取到数据的结果.系统会根据回调计算耗电量和App在后台的时间,系统会根据需要调节App的耗电量以及在后台的时间.</p>
<p>以上就是这段代码所做的事.现在你可以用 <em>contentpush.php</em> 给你的应用发送一个静默通知.请务必确认以下设置脚本的正确性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Put your device token here (without spaces):</span><br><span class="line">$deviceToken = &apos;43e798c31a282d129a34d84472bbdd7632562ff0732b58a85a27c5d9fdf59b69&apos;;</span><br><span class="line"></span><br><span class="line">// Put your private key&apos;s passphrase here:</span><br><span class="line">$passphrase = &apos;WenderCastPush&apos;;</span><br></pre></td></tr></table></figure></p>
<p>在终端直接运行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ php contentpush.php</span><br></pre></td></tr></table></figure></p>
<p>如果一切顺利,什么事都不会发生.为了看到这段代码的运行结果,与之前设置的一样结果必须把scheme设置为”Wait for executable to be launched”并在 <em>application(_:didReceiveRemoteNotification:fetchCompletionHandler:)</em> 方法旁边打上断点,以确认这个方法会被调用.</p>
<h1 id="路在何方"><a href="#路在何方" class="headerlink" title="路在何方?"></a>路在何方?</h1><p>恭喜你已经完成了这份推送通知教程的内容并且WenderCast应用也有全部的推送功能!</p>
<p>你可以在<a href="https://cdn2.raywenderlich.com/wp-content/uploads/2016/03/WenderCast-Final-1.1.zip" target="_blank" rel="external">这里</a>下载完整的工程.记住为了能让工程正常运行你仍然需要更改Bundle ID和证书.</p>
<p>推送通知功能对于现在的App已经是一个不可或缺的部分,但如果你发送的通知太频繁用户仍然会调整你的通知请求许可.对于一个深思熟虑的设计,推送通知会让你的应用保持足够的用户粘性!</p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/cat-1136365_1280-768x512.jpg" alt="cat-1136365_1280-768x512"></p>
<h2 id="这只猫接收到”推送通知”后它就知道晚餐已经准备好了"><a href="#这只猫接收到”推送通知”后它就知道晚餐已经准备好了" class="headerlink" title="这只猫接收到”推送通知”后它就知道晚餐已经准备好了"></a><em>这只猫接收到”推送通知”后它就知道晚餐已经准备好了</em></h2><p>我希望你能喜欢这份推送教程.如果你有任何问题,你可以在下面的评论中随意提问.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iPad横竖屏代码适配]]></title>
      <url>http://jmstack.github.io/2016/03/05/iPad%E6%A8%AA%E7%AB%96%E5%B1%8F%E4%BB%A3%E7%A0%81%E9%80%82%E9%85%8D/</url>
      <content type="html"><![CDATA[<p>你可能非常了解用不同的方式去适配不同尺寸的iPhone屏幕,在适配iPhone屏幕时你需要考虑的只是屏幕大小变化带来的UI元素间隔的变化,但是在iPad上主要针对的是横竖屏下完全不同的UI元素的布局,在这种情况下要考虑的就不仅仅是元素之间间隔这种问题了,除了要确保UI元素在这两种模式下的正确显示还要兼顾屏幕旋转的过渡动画.下图是QQZone For iPad 在横竖屏下的布局,可以看到横竖屏下菜单栏的布局方式差别很大.</p>
<p>QQZone for iPad <a href="https://github.com/JMStack/QQZone" target="_blank" rel="external">GitHub地址</a><br><a id="more"></a></p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/QQZone%E6%A8%AA%E5%B1%8F.PNG" alt="QQZone for iPad 竖屏"><br><img src="http://o6jvfp7kw.bkt.clouddn.com/QQZone%E7%AB%96%E5%B1%8F.PNG" alt="QQZone for iPad 横屏"></p>
<h2 id="屏幕适配的N种方法"><a href="#屏幕适配的N种方法" class="headerlink" title="屏幕适配的N种方法"></a>屏幕适配的N种方法</h2><p>无论iPad还是iPhone适配不同屏幕(尺寸,方向)的方式都跑不出以下几种,以下会一一对不同方式做一下简单的回顾.</p>
<h3 id="Autoresizing"><a href="#Autoresizing" class="headerlink" title="Autoresizing"></a>Autoresizing</h3><p>Autoresizing可以说是Autolayout始祖,Autoresizing的是一项比较有历史的技术了,其在iOS2的时代就推出了.当设置UIView实例对象的autoresizesSubviews属性为true(默认值为true),那么其子view会根据自已的autoresizingMask属性值自动调整与superview的位置和大小关系.autoresizingMask有六种可组合的使用的值,默认值是.None.这六种有效枚举值的意思如下:</p>
<ul>
<li>FlexibleLeftMargin   按比例跟随父控件变化的左间距</li>
<li>FlexibleWidth        按比例跟随交控件变化的宽度</li>
<li>FlexibleRightMargin  按比例跟随父控件变化的右间距</li>
<li>FlexibleTopMargin    按比例跟随父控件变化的顶部间距</li>
<li>FlexibleHeight       按比例跟随控件变化的高度</li>
<li>FlexibleBottomMargin 按比例跟随父控件变化的底部间距</li>
</ul>
<p>另外在xib,storyboard取消Autolayout时(Autoresizing与Autolayout相互冲突)可以在Size inspector可以更加直观地按需求进行组和使用.Autoresizing技术在一定应用场景下可以勉强使用但应对更为精细的布局就无能为力了,你可以在使用Autoresizing同时重写layoutSubviews方法去做更为精细的布局,尽管如此但还是不推荐这么做,因为同时得写layoutSubviews和使用Autoresizing去布局会让你的布局逻辑变得不清晰,这将给后期的维护带来麻烦.</p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/SizecClass.png" alt="Autoresizing in storyboard"></p>
<h3 id="Autolayout"><a href="#Autolayout" class="headerlink" title="Autolayout"></a>Autolayout</h3><p>Autolayout是iOS6时代引入的技术,专门用来处理不同屏幕尺寸下的UI布局.从Xcode6开始Autolayout配合xib,storyboard极大的提高屏幕的适配工作效率.在一定程度上甚至可以完全摆脱设置frame布局的方式.由于storyboard,xib在多人合作开发冲突不断的尴尬境地,在实际的开发中多使用第三方框架用代码进行Autolayout布局.这样既避免了解决冲突麻烦又享受到了Autolayout带来的宏利.比较受欢迎的Autolayout每三方框架有<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">Masonry</a>还有<a href="http://weibo.com/gsdios?profile_ftype=1&amp;is_all=1#_0" target="_blank" rel="external">GSD_iOS</a>大神的<a href="https://github.com/gsdios/SDAutoLayout" target="_blank" rel="external">SDAutoLayout</a></p>
<p>尽管Autolayout有很多好处但还是很多代码党不愿使用,究其原因还是约束.约束的问题大至可以分约束冲突和约束不满足两大类,当在storyboard中对一个复杂的界面进行Autolayout约束,一但出现问题将很难排查,用代码行约束往往程序运行起来才能确认约束是否满足条件,同样排查起来也不是那么方便.关于Autolayout这不再占用过多的篇幅,网上有相当多的资料可供参考.</p>
<h3 id="SizeClass"><a href="#SizeClass" class="headerlink" title="SizeClass"></a>SizeClass</h3><p>SizeClass是要配合Autolayout使用的,SizeClass实际上是对屏幕尺寸的抽象,把屏幕宽高分成Compact:紧凑、Regular:宽松、Any:任意三种类型这样就可以组合出九种不同的屏幕类型.在storyboard,xib编辑界面下最下方可以选择某一约束在只在某一类屏幕下生效.这样可以在不同屏幕下得到不同的UI布局效果.关于SizeClass的使用可以参考<a href="https://www.raywenderlich.com/113768/adaptive-layout-tutorial-in-ios-9-getting-started" target="_blank" rel="external">raywenderlich</a>系例文章.</p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/AutoLayout.png" alt="SizeClass"></p>
<h3 id="代码计算坐标"><a href="#代码计算坐标" class="headerlink" title="代码计算坐标"></a>代码计算坐标</h3><p>在所有的布局方法中这种可能是最费体力的一项,因为所有的UI元素都需要一个一个明确的计算或者指定出来.尽管如此正因为每个元素的frame是手动计算因此灵活性也非常大你可以随心所欲的计算每个控件的frame,出现问题时也非常好排查.如果需要动态的改变view的frame就需要重写父控件的layoutSubviews方法,在重写的layoutSubviews明确计算出frame. 如果view是固定的则只需要在添加到父控件时指定view的frame.一般常见的代码布局形式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override func layoutSubviews() &#123;</span><br><span class="line">    super.layoutSubviews()</span><br><span class="line">    let x: CGFloat = 0</span><br><span class="line">    let y: CGFloat = frame.height * 0.7 // 根据父控件高度按比例确定y座标</span><br><span class="line">    let w: CGFloat = frame.width</span><br><span class="line">    let h: CGFloat = frame.height - y  // 根据父控件高度,子控件按比例调整高度</span><br><span class="line">    subView.frame = CGRectMake(x, y, w, h)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是常见的根据父控件动态调整子控件frame的形式,真实开发中可能还需要考虑横竖屏下动态的布局(下面将提到的),以上基本形式可以根据需求进行扩展.当然你也可以不用重写layoutSubviews方法而在需要改变frame的时机显式直接改变frame,但在这种方式并不符合苹果的逻辑.在view的层次结构中某一view肯定是有superview的,而子view是否变化,以及什么时候变化应是由superview来决定的,在一个多层次结构的view视图中如果显示的设定子view的frame那你不得不根据view的层次结构一级一级的设置子view的frame.superview和subView之前会出现较强的关联性.理想情况下一个superview应该只关注自身的subView的布局,无论这个superview的frame或层次结构怎么变化其subviews并不需要知道.因此我觉得比较好的做法是有所关于subviews的frame的设定都应该重写layoutSubviews,在layoutSubviews中去做.这样做的另一个好处是屏幕旋转时你并不需要显示的去写UIView动画.</p>
<h2 id="layoutsubviews的调用时机"><a href="#layoutsubviews的调用时机" class="headerlink" title="layoutsubviews的调用时机"></a>layoutsubviews的调用时机</h2><p>用代码在layoutSubviews中布局你必需要知道系统会在哪些时机去调用layoutsubviews函数.关于这个问题的结论可以参看<a href="http://stackoverflow.com/questions/728372/when-is-layoutsubviews-called" target="_blank" rel="external">stackoverflow</a>的讨论.关于这个问题我个人比较赞同第二个回答者对第一个回答的纠正.基本上layoutsubviews会在以下几种情况下调用:</p>
<ul>
<li>当view的bounds发生改变时</li>
<li>当view的直接subView的bounds发生改变时</li>
<li>当subView添加或移除时</li>
<li>调用setNeedsLayout方法会在下一个显示周期主动调用layoutsubviews</li>
</ul>
<h2 id="如何获取当前屏幕方向"><a href="#如何获取当前屏幕方向" class="headerlink" title="如何获取当前屏幕方向"></a>如何获取当前屏幕方向</h2><p>关于获取当前屏幕方向我所知道的方法仅包括以下几种:</p>
<ul>
<li>通过控制器的interfaceOrientation只读属性获取,<strong>iOS8后过期</strong></li>
<li>能过状态栏的方向间接获取,UIApplication的只读属性statusBarOrientation,<strong>iOS9后过期</strong></li>
<li>能过UIDevice只读属性orientation获取.需主动调用beginGeneratingDeviceOrientationNotifications开启通知</li>
<li>通过根控制器的view宽高推导获取,当高&gt;宽为竖屏否则为横屏</li>
</ul>
<h2 id="Demo预览"><a href="#Demo预览" class="headerlink" title="Demo预览"></a>Demo预览</h2><p>下面是这个Demo的最终效果,我将通个下面的例子记录我认为合理的代码适配横竖屏的方式.</p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/QQZone%E9%A2%84%E8%A7%88-Slow.gif" alt="Demo预览慢速"><br><img src="http://o6jvfp7kw.bkt.clouddn.com/QQZone%E9%A2%84%E8%A7%88.gif" alt="Demo预览正常"></p>
<h2 id="Demo分析"><a href="#Demo分析" class="headerlink" title="Demo分析"></a>Demo分析</h2><p>上面一些基础的知识将有助于理解Demo的做法,所以尽管有一点废话连篇的感觉好在也并不是一无是处.在讲解Demo的实现思路之前你可以在<a href="https://github.com/JMStack/QQZone" target="_blank" rel="external">GitHub</a>下载这个Demo,以便更方便的查看我讲到的代码.</p>
<p>Demo中最复杂的,横竖屏布局变化最大的部分就是左侧的菜单栏可以称它为Dock栏,通过旋转屏幕可以看到原生QQZone HD的Dock栏的变化.可以根据变化的特征将整个Dock栏分为三部分.一是顶部的头像 二是中间的类TabBar,我称它为TabBar 三是 底部的快捷导航菜单.因此DockView的subview包含iconButton,tabBarView,menuBar三个,而这三个subview又可以分另包含各自的子控件.</p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/Demo%E8%A7%86%E5%9B%BE%E7%BB%93%E6%9E%84.png" alt="view层次结构"></p>
<p>实际上实现QQZone for iPad屏幕的横竖屏的布局并不复杂.一个view要知道怎样在layoutSubviews中去布局其子view只需知道当前其superview的状态(横竖屏).在这里我声明了一个协议,这个协议只包含一个获取当前view是否是竖屏的方法.让每一个需要根据横竖屏动态变化的view都实现这个协议的方法,这样在layoutSubviews方法就可以询问当前应该怎么样布局子控件而当前状态是由父控件状态决定的.由此形成了屏幕状态的传递链,使得每个veiw只关心自身直接subview的布局.<br><figure class="highlight plain"><figcaption><span>UIViewisPortrait协议</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol UIViewisPortrait: NSObjectProtocol &#123;</span><br><span class="line">    func isPortrait() -&gt; Bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根控制器view的任意subview可都可以通过如下代码获取当前是否是竖屏<br><figure class="highlight plain"><figcaption><span>subview 如何获取superview状态</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func isPortrait() -&gt; Bool &#123;</span><br><span class="line">    guard let superview = superview else &#123; // 如果不存大superview默认返回竖屏</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    return ((superview as? UIViewisPortrait)?.isPortrait())!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而根控制器view则直接通过宽高获取屏幕状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func isPortrait() -&gt; Bool &#123;</span><br><span class="line">    return frame.width &lt; frame.height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当前view知道是横竖屏后就可以直接在layoutsubviews布局子控件了,以menuBar为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">override func layoutSubviews() &#123;</span><br><span class="line">    super.layoutSubviews()</span><br><span class="line">    guard subviews.count &gt; 0 else &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var x, y, w, h:CGFloat</span><br><span class="line">    for (index, view) in subviews.enumerate() &#123;</span><br><span class="line">        if isPortrait() == true &#123;</span><br><span class="line">            w = frame.width</span><br><span class="line">            h = kDockItemHeight</span><br><span class="line">            x = 0</span><br><span class="line">            y = CGFloat(index) * h</span><br><span class="line">            view.frame = CGRect(x: x, y: y, width: w, height: h)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            w = frame.width / CGFloat(subviews.count)</span><br><span class="line">            h = kDockItemHeight</span><br><span class="line">            x = CGFloat(index) * w</span><br><span class="line">            y = frame.height - h</span><br><span class="line">            view.frame = CGRect(x: x, y: y, width: w, height: h)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其它类型的所有子控件都可以用类似的方法进行布局,如此你只需要定义一个view并始之成为某个View的subview,在你定义的view中你可以随意的获取屏幕状态布局子控件了.</p>
<p>为了在根控制器View的layoutSubviewsr的方法中布局DockView,需要重写控制器的loadView方法,让控制器加载自定义的View. 如果你注意到原生QQZone for iPad的内容显示区域在横竖屏下的变化会发现在横坚屏下内容显示区域宽都是一样的,所以还需要在根控制器View中添加一个容器View以显示内容.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class HomePageView: UIView, UIViewisPortrait &#123;</span><br><span class="line">    private lazy var dockView:DockView = DockView()</span><br><span class="line"></span><br><span class="line">    lazy var contentView: UIView = &#123;</span><br><span class="line">        let contentView = UIView()</span><br><span class="line">        contentView.backgroundColor = UIColor.whiteColor()</span><br><span class="line">        // 作为容器View,子控制器的view将添加到容器view上</span><br><span class="line">        self.addSubview(contentView)</span><br><span class="line">        return contentView</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    func isPortrait() -&gt; Bool &#123;</span><br><span class="line">        return frame.width &lt; frame.height</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override init(frame: CGRect) &#123;</span><br><span class="line">        super.init(frame: frame)</span><br><span class="line">        addSubview(dockView)</span><br><span class="line">        dockView.backgroundColor = globalBackgroudColor</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    required init?(coder aDecoder: NSCoder) &#123;</span><br><span class="line">        fatalError(&quot;init(coder:) has not been implemented&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override func layoutSubviews() &#123;</span><br><span class="line">        super.layoutSubviews()</span><br><span class="line">        dockView.frame.size.height = frame.height</span><br><span class="line">        dockView.frame.size.width = isPortrait() ? kDockProtraitWidth : kDockLandscapeWidth</span><br><span class="line"></span><br><span class="line">        let x: CGFloat = dockView.frame.width</span><br><span class="line">        let y: CGFloat = 20</span><br><span class="line">        // 无论横竖屏,内容视图的宽都一样</span><br><span class="line">        let w: CGFloat = min(frame.width, frame.height) - kDockProtraitWidth</span><br><span class="line">        let h: CGFloat = frame.height - y</span><br><span class="line"></span><br><span class="line">        contentView.frame = CGRectMake(x, y, w, h)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后由于内容区域不用区分横竖屏,因此内容区域的子视图可以只考虑竖屏的情况,以上可以说得不是很清楚,如果感觉有兴趣可<a href="https://github.com/JMStack/QQZone" target="_blank" rel="external">下载</a>原码参阅.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上重点仅仅是用代码进行iPad横竖屏适配方法的探讨,这里只是记录了我认为较为合理的方法,当然这种方法可能并不适用所有的布局,毕竟每个App都有自己独特的UI部分.如果觉得这种方法不好欢迎指出,我将虚心请教.如果这个方法对你的业务提供了一点点的灵感希望点个赞,以上完.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微博,微信图片浏览过渡动画的实现]]></title>
      <url>http://jmstack.github.io/2016/02/02/%E5%BE%AE%E5%8D%9A-%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E6%B5%8F%E8%A7%88%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>大家在平常用微信,微博的过程中肯定(对,就是肯定)都有查看过朋友圈和微博所发布的照片,当点击九宫格的某一图片时图片会慢慢的放大并进入全屏,左右滑动查看另一张.轻点图片又会以动画的方式慢慢缩小回到滑动之后对应的图片.说了这么多估计你还是不知道我在讲什么鬼,一张动图胜过千言万语.毕竟语言这东西真不是码农的特长…</p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/%E5%BE%AE%E5%8D%9A%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%9B%BE.gif" alt="微博九宫格"><br><a id="more"></a><br><img src="http://o6jvfp7kw.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E4%B9%9D%E5%AE%AB%E6%A0%BC.gif" alt="微信九宫格"></p>
<p>上面两张gif点开时的动画不是很明显,你可以在真机上查看更真实效果.接下来我会通过一个Demo来介绍实现这种效果的具体思路,如果你有更好的思路,请求赐教</p>
<hr>
<h1 id="Demo-预览"><a href="#Demo-预览" class="headerlink" title="Demo 预览"></a>Demo 预览</h1><p>在开始之前先看一看最终的效果</p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/Demo%E9%A2%84%E8%A7%88.gif" alt="Demo 预览"></p>
<p>这个Demo抓取了<a href="http://www.meilishuo.com" target="_blank" rel="external">美丽说</a>的在线图片,这里对毫不知情的美丽说表示感谢.<br>在看下面的部分之前假定你已经撑握了Swift,网络请求,会使用UICollectionView等基础组件的技能.如若不能撑握建议先了解相关知识</p>
<p><em>Demo<a href="https://github.com/JMStack/PhotoBrowse.git" target="_blank" rel="external">GitHub地址</a></em></p>
<h1 id="Demo-结构分析"><a href="#Demo-结构分析" class="headerlink" title="Demo 结构分析"></a>Demo 结构分析</h1><p>在Demo中主要包括两个主要的视图结构:一 缩略图(主视图)的浏览 二 大图的浏览. 这两个视图中所要展示的内容都是有规律的矩形所以都可以用UICollectionView来实现.<br>两者的区别在于缩略图是垂直方向的布局而大图是水平方向上的布局方式.两个UICollectionView的cell的内容只包含一个UIImageView.在大图浏览视图中有一个<br>需要注意的细节:为了图片浏览的效果每张图片之间是有一定间隔的,如果让每个cell都填充整个屏幕,图片的宽度等于cell的宽度再去设置cell的间隔来达到间隔的效果会在停止滑动图片时黑色的间隔会显现在屏幕中(如下图),这并不是我们想看到的结果.</p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/%E9%94%99%E8%AF%AF%E7%9A%84%E5%A4%A7%E5%9B%BEcell%E5%AE%BD%E8%AE%BE%E7%BD%AE.png" alt="错误的大图cell宽设置"></p>
<p>出现这个问题的原因是UICollectionView的分页(pagingEnabled)效果是以UICollectionView的宽来滚动的,也就是说不管你的cell有多大每次滚动总是一个UICollectionView自身的宽.要实现这个效果有个小技巧,相关内容会在<strong>大图浏览的实现</strong>一节中介绍.</p>
<h1 id="主视图图片浏览的实现"><a href="#主视图图片浏览的实现" class="headerlink" title="主视图图片浏览的实现"></a>主视图图片浏览的实现</h1><p>根据上一节得出的结论,主视图采用colletionview,这部分实现没什么特别的技巧,但在添加collectionview之前需要添加几个基础组件.<br>因为我们所需的图片是抓取美丽说的网络图片,所以我们需要一个网络请求组件,另外为展示图片还需要添加对应的数据模型.但这两个组件的内容不是本篇博文主要讨论的问题<br>另外这两个组件相对较基础,就不废太多口水.具体实现可以参看<a href="https://github.com/JMStack/PhotoBrowse.git" target="_blank" rel="external">GitHub</a>源码,每次网络请求这里设置为30条数据,这里提到也是为了让你在下面的章节看到相关部分不至于感到疑惑,<br>添加完这两个基础组件之后,就可以实现缩略图的浏览部分了.为方便起见缩略图view的控制器采用UICollectionViewController,在viewDidLoad函数中设置流水布局样式,实现collectionview的datasource,delegate.这部分都是一些常规的写法,这里要关注的是datasource和delegate的下两个函数.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">override func collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -&gt; UICollectionViewCell &#123;</span><br><span class="line">    // 从缓存池中取出重用cell</span><br><span class="line">    let cell = collectionView.dequeueReusableCellWithReuseIdentifier(reuseIdentifier, forIndexPath: indexPath) as? CollectionViewCell</span><br><span class="line">    // 从模形数组中取出相应的模形</span><br><span class="line">    let item = shopitems[indexPath.item];</span><br><span class="line">    // 设置模形数据为显示缩略图模式</span><br><span class="line">    item.showBigImage = false</span><br><span class="line">    // 把模形数据赋值给cell,由cell去决定怎样显示,显示什么内容</span><br><span class="line">    cell?.item = item</span><br><span class="line">    // 当滑动到到最后一个cell时请求加载30个数据</span><br><span class="line">    if indexPath.item == shopitems.count - 1 &#123;</span><br><span class="line">        loadMoreHomePageData(shopitems.count)</span><br><span class="line">    &#125;</span><br><span class="line">    return cell!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里为使Demo不过于复杂,没有用什么”上拉加载更多”控件,每次滑动到到最后一个cell时请求加载30个数据方式同样能获得良好的滑动体验</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">override func collectionView(collectionView: UICollectionView, didSelectItemAtIndexPath indexPath: NSIndexPath) &#123;</span><br><span class="line">    // 当点击某个cell时, 创建大图浏览控制器</span><br><span class="line">    let photoVC = PhotoBrowseCollectionVC()</span><br><span class="line">    // 当前点击cell的indexPathw传给控制器,以使大图浏览器直接显示对应图片</span><br><span class="line">    photoVC.indexPath = indexPath</span><br><span class="line">    // 当前模型数组的内容传给控制器,以使大图浏览能左右滑动</span><br><span class="line">    photoVC.items = shopitems</span><br><span class="line">    // 先以正常形式modal出大图浏览</span><br><span class="line">    presentViewController(photoVC, animated: true, completion: nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先以正常的样式(从底部弹出)modal出大图浏览视图,当缩略图和大图的逻辑跳转逻辑完成后再来完善画动逻辑</p>
<h1 id="大图浏览的实现"><a href="#大图浏览的实现" class="headerlink" title="大图浏览的实现"></a>大图浏览的实现</h1><p>与缩略图一样,大图浏览也是一个collectionView.这里为大图浏览控制器添加了一个<a href="http://wiki.jikexueyuan.com/project/swift/chapter2/14_Initialization.html" target="_blank" rel="external">便利构造器</a>,以便在点击缩略图时快速创建固定流水布局的collectionView.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">convenience init() &#123;</span><br><span class="line">        let layout = UICollectionViewFlowLayout()</span><br><span class="line">        layout.itemSize = CGSize(width: UIScreen.mainScreen().bounds.width + cellMargin, height: UIScreen.mainScreen().bounds.height)</span><br><span class="line">        layout.minimumLineSpacing = 0</span><br><span class="line">        layout.minimumInteritemSpacing = 0</span><br><span class="line">        layout.scrollDirection = .Horizontal</span><br><span class="line">        self.init(collectionViewLayout: layout)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在<strong>Demo 结构分析</strong>一节中遗留了一个问题,其实要实现全屏图像间隔效果非常简单,只要把collectionView和cell的宽设置为屏宽加固定的间距并且cell之间间距为0<br>而图片只显示在屏幕正中间(图片与屏等宽),这样在开启pagingEnabled的情况下每次滑动都是滑动一个(图片宽度+间距),相当于在cell中留了一个边距来作间隔而不是在cell<br>外做间隔,可以参看下图</p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/%E5%9B%BE%E7%89%87%E9%97%B4%E9%9A%94%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt=""></p>
<p>上图中有两个cell,cell的间距是零.开启pagingEnabled时,每次移动都是一个cell的宽,这样停止滑动时间隔就不会出现在屏幕中了.<br>大图浏览的collectionView的实现代码几乎与缩略图一样,需要注意的是当modal出大图的时候collectionView是要直接显示对应大图的,这也是为什么在缩略视图控制器的didSelectItemAtIndexPath函数中要传递indexPath的原因.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    // 大图colletionview的frame</span><br><span class="line">    collectionView?.frame = UIScreen.mainScreen().bounds</span><br><span class="line">    collectionView?.frame.size.width = UIScreen.mainScreen().bounds.size.width + cellMargin</span><br><span class="line">    // 开启分页</span><br><span class="line">    collectionView?.pagingEnabled = true</span><br><span class="line">    // 注册重用cell</span><br><span class="line">    collectionView?.registerClass(CollectionViewCell.self, forCellWithReuseIdentifier: cellID)</span><br><span class="line">    // collectionView显示时跳转到应的图片</span><br><span class="line">    collectionView?.scrollToItemAtIndexPath(indexPath!, atScrollPosition: .Left, animated: false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中scrollToItemAtIndexPath函数的atScrollPosition参数的意思是停止滚动时对应的cell与collectionView的位置关系,Left是cell的左边与colletionview的<br>左边对齐.其它的对应关系可依此类推就不废话了. collectionView的比较重要代理函数的实现如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">override func collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -&gt; UICollectionViewCell &#123;</span><br><span class="line">    let cell = collectionView.dequeueReusableCellWithReuseIdentifier(cellID, forIndexPath: indexPath) as! CollectionViewCell</span><br><span class="line"></span><br><span class="line">    let item = items![indexPath.item]</span><br><span class="line">    item.showBigImage = true</span><br><span class="line">    cell.item = item</span><br><span class="line"></span><br><span class="line">    return cell</span><br><span class="line">&#125;</span><br><span class="line">override func collectionView(collectionView: UICollectionView, didSelectItemAtIndexPath indexPath: NSIndexPath) &#123;</span><br><span class="line">    dismissViewControllerAnimated(true, completion: nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>说重要是因为要与缩略图控制器的代理函数对比看,cellForItemAtIndexPath只是常规的设置数据,选中cell直接dismiss当前控制器.<br>至此缩略图和大图的跳转逻辑你已经清楚了,下面的部分才本博文要讲的真正内容.其实上面分析那么多废话也是因为present和dismiss的动画与跳转前后两个控制器有密切关系</p>
<h1 id="modal出一个View的原理"><a href="#modal出一个View的原理" class="headerlink" title="modal出一个View的原理"></a>modal出一个View的原理</h1><p>默认从底部弹出view的modal方式是将要显式的view添加到一个容器view中,然后对容器view添加动画效,动画结束后把跳转之前控制器的view从window中移除.在window中之前<br>的view完全被弹出的view替代最终看到如下图的视图结构</p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/modal%20%E8%A7%86%E5%9B%BE%E7%BB%93%E6%9E%84.png" alt="modal视图结构"></p>
<p>如你在上图中看到的,黑色的是window,蓝色的为弹出的View,而中间的就是容器View.容器view的类型是UITransitionView<br>dismiss的过程是present的逆过程,除了从底部弹出的动画UIKit还提供了多种动画效果可以通过设置弹出控制器modalTransitionStyle属性.<br>这里有个需要注意点,当设置modalPresentationStyle为Custom时原控制器的view并不会从window中移除.同时如果设置了transitioningDelegate<br>那么modalTransitionStyle设置的动画效果将全部失效,此时动画全权交给代理来完成. UIViewControllerTransitioningDelegate协议包含五个函数<br>这里只需要关注Getting the Transition Animator Objects的两个函数,这两个函数都需要返回一个实现UIViewControllerAnimatedTransitioning协议的实例对象,<br>具体的动画逻辑将在这个实例对象的方法中完成.</p>
<h1 id="添加点击跳转到大图浏览动画"><a href="#添加点击跳转到大图浏览动画" class="headerlink" title="添加点击跳转到大图浏览动画"></a>添加点击跳转到大图浏览动画</h1><p>按上一节的分析需要在点击缩略图时把大图控制器的modalPresentationStyle设为.Custom,并且过渡动画(transitioningDelegate)设置代理对象,具体代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override func collectionView(collectionView: UICollectionView, didSelectItemAtIndexPath indexPath: NSIndexPath) &#123;</span><br><span class="line">    let photoVC = PhotoBrowseCollectionVC()</span><br><span class="line">    photoVC.indexPath = indexPath</span><br><span class="line">    photoVC.items = shopitems</span><br><span class="line">    photoVC.transitioningDelegate = modalDelegate</span><br><span class="line">    photoVC.modalPresentationStyle = .Custom</span><br><span class="line">    presentViewController(photoVC, animated: true, completion: nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>modalDelegate是ModalAnimationDelegate的实例对象,其实现了UIViewControllerTransitioningDelegate协议方法,animationControllerForPresentedController<br>返回本身的实例对象,所以ModalAnimationDelegate也要实现UIViewControllerAnimatedTransitioning协议方法.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</span><br><span class="line">   return self</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在具体的动画逻辑就转到了UIViewControllerAnimatedTransitioning协议的animateTransition方法中.要实现从选中的图片慢慢放大的效果分成如下几步</p>
<ul>
<li>取出容器view,也就是上一节提到的UITransitionView实例对象</li>
<li>取出要弹出的目标view,在这里就是展示大图的colletionview,并添加到容器view</li>
<li>新建UIImageView对象,得到选中的UIImage对像,及其在window上的frame</li>
<li>把新建的UIImageView对象添加到容器view</li>
<li>设置新建UIImageView的放大动画,动画结果束后从容器view中移除</li>
<li>通知系统动画完成(主动调用completeTransition)</li>
</ul>
<p>把动画的实现分解开来是不是清晰很多了,具体实现还是得参看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">func presentViewAnimation(transitionContext: UIViewControllerContextTransitioning) &#123;</span><br><span class="line"></span><br><span class="line">    // 目标view</span><br><span class="line">    let destinationView = transitionContext.viewForKey(UITransitionContextToViewKey)</span><br><span class="line">    // 容器view</span><br><span class="line">    let containerView = transitionContext.containerView()</span><br><span class="line">    guard let _ = destinationView else &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // 目标view添加到容器view上</span><br><span class="line">    containerView?.addSubview(destinationView!)</span><br><span class="line">    // 获取目标控制器</span><br><span class="line">    let destinationController = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey) as? PhotoBrowseCollectionVC</span><br><span class="line">    let indexPath = destinationController?.indexPath</span><br><span class="line">    // 跳转前的控制器</span><br><span class="line">    let collectionViewController = ((transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)) as! UINavigationController).topViewController as! UICollectionViewController</span><br><span class="line">    let currentCollectionView = collectionViewController.collectionView</span><br><span class="line">    // 当前选中的cell</span><br><span class="line">    let selectctedCell = currentCollectionView?.cellForItemAtIndexPath(indexPath!) as? CollectionViewCell</span><br><span class="line">    // 新建一个imageview添加到目标view之上,做为动画view</span><br><span class="line">    let annimateViwe = UIImageView()</span><br><span class="line">    annimateViwe.image = selectctedCell?.imageView.image</span><br><span class="line">    annimateViwe.contentMode = .ScaleAspectFill</span><br><span class="line">    annimateViwe.clipsToBounds = true</span><br><span class="line">    // 被选中的cell到目标view上的座标转换</span><br><span class="line">    let originFrame = currentCollectionView!.convertRect(selectctedCell!.frame, toView: UIApplication.sharedApplication().keyWindow)</span><br><span class="line">    annimateViwe.frame = originFrame</span><br><span class="line">    containerView?.addSubview(annimateViwe)</span><br><span class="line">    let endFrame = coverImageFrameToFullScreenFrame(selectctedCell?.imageView.image)</span><br><span class="line">    destinationView?.alpha = 0</span><br><span class="line">    // 过渡动画执行</span><br><span class="line">    UIView.animateWithDuration(1, animations: &#123;</span><br><span class="line">        annimateViwe.frame = endFrame</span><br><span class="line">    &#125;) &#123; (finished) in</span><br><span class="line">        transitionContext.completeTransition(true)</span><br><span class="line">        UIView.animateWithDuration(0.5, animations: &#123;</span><br><span class="line">            destinationView?.alpha = 1</span><br><span class="line">        &#125;) &#123; (_) in</span><br><span class="line">            annimateViwe.removeFromSuperview()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的关键是怎样通过transitionContext拿到两个控制器.通过UITransitionContextFromViewControllerKey拿到的是转跳前控制器的父控制器,由于Demo中缩略图控制器内嵌了导航控制器所以在Demo中拿到就是导航控制器,经过一系列的转换才能拿到选中的图片.拿到选中的图片后需要计算动画开始和结束的frame,开始的frame是将选中的cell座标直接转换到window上<br>结束的frame是UIImageView放大到屏宽并居中的frame,具体计算方法参看Demo的coverImageFrameToFullScreenFrame全局函数.<br>另外UIViewControllerAnimatedTransitioning协议另一个必须要实现的函数是transitionDuration,这个函数决定了动画执行的时长.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval &#123;</span><br><span class="line">        return 1.0</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="添加轻击回到小图浏览动画"><a href="#添加轻击回到小图浏览动画" class="headerlink" title="添加轻击回到小图浏览动画"></a>添加轻击回到小图浏览动画</h1><p>轻击dismiss的过程与上一节弹出正好相反,但仍有所区别.过程如下:</p>
<ul>
<li>取出弹出的大图colletionview,得到当前轻击的图片</li>
<li>新建UIImageView作为动画view,并把上一步得到的image给新建UIImageView</li>
<li>得到选中图片在window上的frame,并设置为新建UIImageView动画的开始frame</li>
<li>得到当前轻击的大图对应的缩略图的frame,并将其做为动画结束frame</li>
<li>执行动画,动画结束后移除UIImageView</li>
<li>通知系统动画完成(主动调用completeTransition)</li>
</ul>
<p>与present过程不同的是UITransitionContextFromViewControllerKey和UITransitionContextToViewControllerKey两个key正好相反,present过程的FromVC是缩略图的父控制器,toTV是大图浏览控制器.而dismiss与present是相反的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func dismissViewAnimation(transitionContext: UIViewControllerContextTransitioning) &#123;</span><br><span class="line">    let transitionView = transitionContext.viewForKey(UITransitionContextFromViewKey)</span><br><span class="line">    let contentView = transitionContext.containerView()</span><br><span class="line">    // 取出modal出的来控制器</span><br><span class="line">    let destinationController = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey) as! UICollectionViewController</span><br><span class="line">    // 取出当前显示的collectionview</span><br><span class="line">    let presentView = destinationController.collectionView</span><br><span class="line">    // 取出控制器当前显示的cell</span><br><span class="line">    let dismissCell = presentView?.visibleCells().first as? CollectionViewCell</span><br><span class="line">    // 新建过渡动画imageview</span><br><span class="line">    let animateImageView = UIImageView()</span><br><span class="line">    animateImageView.contentMode = .ScaleAspectFill</span><br><span class="line">    animateImageView.clipsToBounds = true</span><br><span class="line">    // 获取当前显示的cell的image</span><br><span class="line">    animateImageView.image = dismissCell?.imageView.image</span><br><span class="line">    // 获取当前显示cell在window中的frame</span><br><span class="line">    animateImageView.frame = (dismissCell?.imageView.frame)!</span><br><span class="line">    contentView?.addSubview(animateImageView)</span><br><span class="line">    // 缩略图对应的indexPath</span><br><span class="line">    let indexPath = presentView?.indexPathForCell(dismissCell!)</span><br><span class="line">    // 取出要返回的控制器view</span><br><span class="line">    let originView = ((transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey) as! UINavigationController).topViewController as! UICollectionViewController).collectionView</span><br><span class="line">    var originCell = originView!.cellForItemAtIndexPath(indexPath!)</span><br><span class="line">    // 得到返回后对应cell在window上的frame</span><br><span class="line">    let originFrame = originView?.convertRect(originCell!.frame, toView: UIApplication.sharedApplication().keyWindow)</span><br><span class="line">    UIView.animateWithDuration(1, animations: &#123;</span><br><span class="line">        animateImageView.frame = originFrame!</span><br><span class="line">        transitionView?.alpha = 0</span><br><span class="line">    &#125;) &#123; (_) in</span><br><span class="line">        animateImageView.removeFromSuperview()</span><br><span class="line">        transitionContext.completeTransition(true)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>present和dismiss时都会调用到UIViewControllerAnimatedTransitioning协议的animateTransition方法,为区分dismiss和present的动画,定义一个属性isPresentAnimationing表明当前要执行的是dismiss还是present,而当前执行的动画是由UIViewControllerTransitioningDelegate协议的animationControllerForPresentedController和animationControllerForDismissedController两个函数决定的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</span><br><span class="line">   isPresentAnimationing = true</span><br><span class="line">   return self</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func animationControllerForDismissedController(dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</span><br><span class="line">   isPresentAnimationing = false</span><br><span class="line">   return self</span><br><span class="line">&#125;</span><br><span class="line">func animateTransition(transitionContext: UIViewControllerContextTransitioning) &#123;</span><br><span class="line">    isPresentAnimationing ? presentViewAnimation(transitionContext) : dismissViewAnimation(transitionContext)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="要注意的问题"><a href="#要注意的问题" class="headerlink" title="要注意的问题"></a>要注意的问题</h1><p>其实上在dismiss动画逻辑留下了一个坑,dismiss时需要获取对应缩略图的cell进而得到动画结束的frame,而获取这个cell用了cellForItemAtIndexPath方法</p>
<figure class="highlight plain"><figcaption><span>dismissViewAnimation 函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">let originView = ((transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey) as! UINavigationController).topViewController as! UICollectionViewController).collectionView</span><br><span class="line">var originCell = originView!.cellForItemAtIndexPath(indexPath!)</span><br><span class="line">// 得到返回后对应cell在window上的frame</span><br><span class="line">let originFrame = originView?.convertRect(originCell!.frame, toView: UIApplication.sharedApplication().keyWindow)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>而cellForItemAtIndexPath只能返回正在显示的cell,没有被显示的cell将返回nil.所以当大图对应的缩略图没有被显示在colletionview中时强制解包就会抛出异常.也就是说当选择查看当前显示缩略图的最后一张对应的大图时就会闪退.解决的办是若用cellForItemAtIndexPath取不到cell则将应的cell滚动到可视范围内,由于cellForItemAtIndexPath需要下一个显示周期才能显示所以要主动调用layoutIfNeeded,实现如下</p>
<figure class="highlight plain"><figcaption><span>dismissViewAnimation 函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var originCell = originView!.cellForItemAtIndexPath(indexPath!)</span><br><span class="line">if originCell == nil &#123;</span><br><span class="line">    originView?.scrollToItemAtIndexPath(indexPath!, atScrollPosition: .CenteredVertically, animated: false)</span><br><span class="line">    originView?.layoutIfNeeded()</span><br><span class="line">&#125;</span><br><span class="line">originCell = originView!.cellForItemAtIndexPath(indexPath!)</span><br><span class="line">let originFrame = originView?.convertRect(originCell!.frame, toView: UIApplication.sharedApplication().keyWindow)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面啰啰嗦嗦写了很多我认为是废话的话,其实实现类似微信微博的图片浏览动画的核心在于dismissViewAnimation和presentViewAnimation函数.本文只是通过一个简单的demo实现了相同的效果,为大家在自己项目中实现类似效果提供一个可参考的思路.当然本人水平有限,或许你知道更简单有效的方法希望也告知我.</p>
]]></content>
    </entry>
    
  
  
</search>
