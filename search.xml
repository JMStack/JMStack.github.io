<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[远程通知推送教程]]></title>
      <url>http://lemtter.com/2016/05/11/%E8%BF%9C%E7%A8%8B%E9%80%9A%E7%9F%A5%E6%8E%A8%E9%80%81%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>版权声明</strong> 本文翻译自:<a href="https://www.raywenderlich.com/123862/push-notifications-tutorial" target="_blank" rel="external">raywenderlich.com</a> 原文作者: <a href="https://twitter.com/JackTripleU" target="_blank" rel="external">Jack Wu</a> 译者: <a href="http://lemtter.com">JMStack</a> 转载请说明原文及译文出处.</p>
</blockquote>
<p>iOS开发者们喜欢想象他的用户们会每时每刻使用他们所开发的APP,但是残酷的事实是他们的用户会有关闭APP来处理其它事情的时候.就像你洗好的衣服总要人去叠吧.</p>
<p>幸好,推送通知功能可以让开发者与用户建立连接并进行简单的交互即使用户当前并没有使用APP!</p>
<p>从推送通知功能第一次问世到现在已经变得越来越强大.在iOS9上,远程推送可以做到:</p>
<ul>
<li>显示短文本</li>
<li>播放通知提示音</li>
<li>设置APP图标的角标</li>
<li>在不打开APP的情况下,允许用户与APP交互</li>
<li>允许APP在后台静默唤醒来执行任务</li>
</ul>
<p>这份远程推送通知教程会告诉你远程推送的工作原理的并让你了解它的一些特性.</p>
<p>在开始推送测试之前你需要具备以下条件:</p>
<ul>
<li><strong>一台iOS设备</strong>.远程推送不能在摸拟器上运行,所以你需要一台真机.</li>
<li><strong>一个开发者帐号</strong> 从Xcode7开始,在真机上测试APP不再需要加入开发者计划.但是为了配置远程推送,你需要有一个与APP ID对应的推送证书,获得这个证书你需要加开发者计划.</li>
</ul>
<a id="more"></a>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>为了接收发送远程推送通知你必须完成以下3个主要的任务:</p>
<ol>
<li>App必须正确配置并注册APNS(Apple Push Notification Service),以便所有设置都完成时就能马上接收到通知</li>
<li>服务端必须向APNS发送一条明确指向一个或多个设备的通知</li>
<li>App必需接收服务端发送的通知;App可以执行通知包含的任务或者在application的代理(delegate)回调方法内处理用户交互行为.</li>
</ol>
<p>任务1和任务3是这份推送通知教程主要关注的内容,因为这两个任务是iOS开发者的工作.</p>
<p>任务2也会在这份教程中简略的提及,并且多数情况仅仅是为了测试目的.发送一个远程通知是App服务端的工作,并且这部分内部会因为App的不同而不同.大多数App都会使用第三方服务(比如Parse.com或者Google ColoudMessaging)推送通知,其它的App或使用定制化的解决方案或使用比较流行的框架(比如: Houston).</p>
<p>正式开始之,下载已经准备好的 <strong>WenderCast</strong> <a href="https://cdn5.raywenderlich.com/wp-content/uploads/2016/03/WenderCast-Starter-1.1.zip" target="_blank" rel="external">开始工程</a>.WenderCast是一个让用户获取raywenderlich.com播客节目和时实消息的应用.</p>
<p>在Xcode中打开WenderCast.xcodeproj简单浏览一下.编绎运行即可查看当前最新播客节目:<br><img src="http://o6jvfp7kw.bkt.clouddn.com/BuildAndRun1.png" alt="BuildAndRun1"><br>这个App的存在的问题是当有新的播客节目可以获取时不能通知到用户.并且也不能显示任何最新的消息.接下来你将用远程推送功能修复这个问题!</p>
<h1 id="为App配置远程推送功能"><a href="#为App配置远程推送功能" class="headerlink" title="为App配置远程推送功能"></a>为App配置远程推送功能</h1><p>推送通知需要较高的安全性.这点是非常重要的,因为你不会想让其它人给你的用户发送通知.这也就意味着要实现远程推送功能你必需跳过一些坑.</p>
<h2 id="打开远程推送服务"><a href="#打开远程推送服务" class="headerlink" title="打开远程推送服务"></a>打开远程推送服务</h2><p>第一步是更改App ID.在Xcode中进入 <strong>App Settings -&gt; General</strong> 把 <strong>Bundle Identifier</strong> 改为任意唯一的字符串.<br><img src="http://o6jvfp7kw.bkt.clouddn.com/ChangeBundleID.png" alt="ChangeBundleID"><br>接下来你需要在你的开发者帐号下添加打开了推送通知功能的App ID.幸运的是,Xcode有更简单的方法实现这个步骤.进入 <strong>App Settings -&gt; Capabilities</strong> 把Push Notifications设置为 <strong>On</strong>.<br>在Xcode完成一些下载后,看起应该会是下面的样子<br><img src="http://o6jvfp7kw.bkt.clouddn.com/PushNotificaitonCapability.png" alt="PushNotificaitonCapability"><br>这个步骤背后的操作是: 如果你当前的开发者帐号下没有对应的App ID就会主动创建App ID,并且打开推送通知功能.你可以登陆开发者中心确认是否打开了这个功能:<br><img src="http://o6jvfp7kw.bkt.clouddn.com/blog/%E8%BF%9C%E7%A8%8B%E9%80%9A%E7%9F%A5%E6%8E%A8%E9%80%81%E6%95%99%E7%A8%8B/MemberCenter1.png" alt="MemberCenter1"></p>
<p>如果这个过程中出现问题,可以手动创建App ID或者点击开发者中心 <strong>+</strong> 或 <strong>Edit</strong> 按钮开启推送通知功能.</p>
<p>以上就是你目前需要的配置.</p>
<h2 id="注册远程推送"><a href="#注册远程推送" class="headerlink" title="注册远程推送"></a>注册远程推送</h2><p>注册远程推送需要两步.第一步,你必需向用户请求推送通知许可,获得许可之后才能注册远程推送.如果所有步骤进行顺利,系统将会向你提供一个 <strong>device token</strong> ,你可以把它认为是当前设备的”地址”.</p>
<p>在WenderCast应用中你需要用在应用启动后立即注册远程推送.</p>
<p>打开AppDelegate.swift,添加以下代码到AppDelegate末尾.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func registerForPushNotifications(application: UIApplication) &#123;</span><br><span class="line">  let notificationSettings = UIUserNotificationSettings(</span><br><span class="line">    forTypes: [.Badge, .Sound, .Alert], categories: nil)</span><br><span class="line">  application.registerUserNotificationSettings(notificationSettings)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法创建了一个 <em>UIUserNotificationSettings</em> 实例对象并把它作为参数传给 <em>registerUserNotificationSettings(_:)</em> .</p>
<p><em>UIUserNotificationSettings</em> 存储你的应用将到用到的通知类型设置.对于UIUserNotificationType的值你可以用下面几个枚举值的任意组合.</p>
<ul>
<li>.Badge 允许App在图标上显示角标数字</li>
<li>.Sound 允许App播放声音</li>
<li>.Alert 允许App显示文本</li>
</ul>
<p><em>UIUserNotificationCategory</em> 是Set类型参数当前暂时传 <em>nil</em>,以允许你指定你的App能够处理的不同类型的通知.当你需要实现可交互的通知时,这样的设置是必需的.后面的部分你将会用到可交互通知.</p>
<p>在 <em>application(_:didFinishLaunchingWithOptions:launchOptions:):</em> 方法内的第一行调用 <em>registerForPushNotifications(_:)</em> :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool &#123;</span><br><span class="line">  registerForPushNotifications(application)</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编绎运行.当App启动时你会收到一个弹窗请求通知许可:<br><img src="http://o6jvfp7kw.bkt.clouddn.com/BuildAndRun2.png" alt="BuildAndRun2.png"></p>
<p>点击 <strong>OK</strong> ,现在App可以显示通知了.但是,如果用户拒绝了发送通知的请求该应怎么办?</p>
<p>当用户接受或拒绝请求许可又或者之前做出过是否允许的选择, <em>UIApplicationDelegate</em> 的一个代理方法将会被调用. 添加以下代码到 <em>AppDelegate</em> :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func application(application: UIApplication, didRegisterUserNotificationSettings notificationSettings: UIUserNotificationSettings) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个方法中,你会接收到另一个 <em>UIUserNotificationSettings</em> 实现对象.这个实例对象与之前你之前所传入的不同.你之前传入的是你所希望的设置,而当前这个是用户当前授权的设置.</p>
<p>在App每次启动时都调用 <em>registerUserNotificationSettings(_:)</em> 是相当重要的.因为用户在任何时候都有可能在设置应用内改变通知的授权许可. <em>application(_:didRegisterUserNotificationSettings:)</em> 方法会告诉你用户当前给你的App什么样的授权许可.</p>
<p>现在第一步已经完成,你可以注册远程推送通知了.这一步相当简单,因为你不再需要向用户请求什么许可了.用下面的代码更新 <em>application(_:didRegisterUserNotificationSettings:)</em> 方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func application(application: UIApplication, didRegisterUserNotificationSettings notificationSettings: UIUserNotificationSettings) &#123;</span><br><span class="line">  if notificationSettings.types != .None &#123;</span><br><span class="line">    application.registerForRemoteNotifications()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的方法中,首先检查当前用户是否允许通知,如果允许直接调用 <em>registerForRemoteNotifications()</em>.</p>
<p>其次, <em>registerForRemoteNotifications()</em> 的请求注册的返回状态会通过 UIApplicationDelegate协议中的某些方法通知你.</p>
<p>添加以下代码到 <em>AppDelegate</em> :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func application(application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: NSData) &#123;</span><br><span class="line">  let tokenChars = UnsafePointer&lt;CChar&gt;(deviceToken.bytes)</span><br><span class="line">  var tokenString = &quot;&quot;</span><br><span class="line"></span><br><span class="line">  for i in 0..&lt;deviceToken.length &#123;</span><br><span class="line">    tokenString += String(format: &quot;%02.2hhx&quot;, arguments: [tokenChars[i]])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  print(&quot;Device Token:&quot;, tokenString)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func application(application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: NSError) &#123;</span><br><span class="line">  print(&quot;Failed to register:&quot;, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就像方法名所暗示的那样,当注册通知成功后系统会调用 <em>application(_:didRegisterForRemoteNotificationsWithDeviceToken:)</em> 方法,否则将会调用 <em>application(_:didFailToRegisterForRemoteNotificationsWithError:).</em> 方法.</p>
<p>当前 <em>application(_:didRegisterForRemoteNotificationsWithDeviceToken:)</em> 方法的实现看起来难以理解,其实它仅仅只是获取 <em>deviceToken</em> 然后转换成字符串.deviceToken的值就是这个过程得到的结果.它是由APNs服务器提供用来标识当前设备当前App.当发送时推送通知的时候,App用deviceToken作为”地址”传递到当前设备.</p>
<blockquote>
<p><strong>注意</strong> 会有很多原因导致注册失败.最常碰到原因是程序运行在模拟器上,或者App ID设置不正确.具体原因打印error值会提供更加详细的信息.</p>
</blockquote>
<p>到此,编绎运行.确保你当前运行在真机上,你将会在控制台看到打印出的device token.下面将会是你看到的结果:<br><img src="http://o6jvfp7kw.bkt.clouddn.com/DeviceToken.png" alt="DeviceToken"></p>
<p>把device token复制到某处保存.</p>
<p>在正式发送通知之前你还需要一点点配置,所以回到开发者中心.</p>
<h2 id="创建一个SSL证书和PEM文件"><a href="#创建一个SSL证书和PEM文件" class="headerlink" title="创建一个SSL证书和PEM文件"></a>创建一个SSL证书和PEM文件</h2><p>在开发者中心进入 <strong>Certificates, Identifiers &amp; Profiles -&gt; Identifiers -&gt; App IDs</strong> 找到你应用的App ID.在 <strong>Application Services</strong> 下面 <strong>Push Notifications</strong> 应该为 <strong>Configurable</strong> :<br><img src="http://o6jvfp7kw.bkt.clouddn.com/ConfigurablePushNotifications.png" alt="ConfigurablePushNotifications"><br>点击 <strong>Edit</strong> 滚动到 <strong>Push Notifications</strong> :<br><img src="http://o6jvfp7kw.bkt.clouddn.com/CreateCertificate.png" alt="CreateCertificate"><br>在 <strong>Development SSL Certificate</strong> 栏下,点击 <strong>Create Certificate…</strong> 接下来的步骤就是创建 <strong>CSR</strong> 文件.创建好CSR文件后点击 <strong>continue</strong> 和 <strong>Generate</strong>,这步会用你创建的CSR文件生成证书.最后下载并运行生成好的证书,证书将被添加到你的钥匙串应用中,并与私钥成对.<br><img src="http://o6jvfp7kw.bkt.clouddn.com/KeychainCertificate.png" alt="KeychainCertificate"></p>
<p>在开发者中心,你的App ID现在推送通知功能在development下应该处于Enable状态.<br><img src="http://o6jvfp7kw.bkt.clouddn.com/PushNotificationEnabled.png" alt="PushNotificationEnabled"></p>
<p>在关闭钥匙串应用前还有最后一件事,右击你刚才添加的证书,选择 <strong>Export</strong> :<br><img src="http://o6jvfp7kw.bkt.clouddn.com/ExportCertificate.png" alt="ExportCertificate"></p>
<p>保存在桌面并命名为WenderCastPush.p12.<br><img src="http://o6jvfp7kw.bkt.clouddn.com/SaveP12.png" alt="SaveP12"></p>
<p>你会被提示要求为你的.p12文件设置密码,你可以选择不输或者输入一个你想设置的密码.这里我用”WenderCastPush”作为密码.接下来你需要输入电脑登陆密码来允许导出p12文件.</p>
<p>接下来,打开你的终端并执行以下命令来从p12文件生成PEM文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/Desktop</span><br><span class="line">$ openssl pkcs12 -in WenderCastPush.p12 -out WenderCastPush.pem -nodes -clcerts</span><br></pre></td></tr></table></figure></p>
<p>如果你导出p12文件时输入了密码,在这里你必须输入相同的密码.</p>
<p>到此为止,你已经艰难的跃过了很多坑,这一切都是值得的.接下来你将用你生成的WenderCastPush.pem文件发送第一个通知.</p>
<h1 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h1><p>之前下载的<a href="https://cdn5.raywenderlich.com/wp-content/uploads/2016/03/WenderCast-Starter-1.1.zip" target="_blank" rel="external">开始工程</a>会包含一个WenderCastPush文件;里面包含两个用于发送通知简单脚本.你需要用到的是newspush.php.正如文件名所暗示的,这个脚本将会向你的用户发送一个弹窗通知消息.</p>
<p>发送推送通知需要和APNS建立SSL连接,SSL连接是用之前创建的证书进行加密.这就是为什么要生成 <strong>WenderCastPush.pem</strong> 文件.重命名 <strong>WenderCastPush.pem</strong> 为 <strong>ck.pem</strong>,并且替换掉当前已经存在于 <strong>WenderCastPush</strong> 文件夹下的 <strong>ck.pem</strong> 文件.</p>
<p>打开 <strong>newspush.php</strong> 并更新之前接收到的 <strong>$deviceToken</strong> 和导出文件时输入的密码 <strong>$passphrase</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Put your device token here (without spaces):</span><br><span class="line">$deviceToken = &apos;43e798c31a282d129a34d84472bbdd7632562ff0732b58a85a27c5d9fdf59b69&apos;;</span><br><span class="line"></span><br><span class="line">// Put your private key&apos;s passphrase here:</span><br><span class="line">$passphrase = &apos;WenderCastPush&apos;;</span><br></pre></td></tr></table></figure></p>
<p>打开终端, <strong>cd</strong> 到 <strong>newspush.php</strong> 所在的文件夹,输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php newspush.php &apos;Breaking News&apos; &apos;https://raywenderlich.com&apos;</span><br></pre></td></tr></table></figure></p>
<p>如果进行顺利,你的终端将会显示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connected to APNS</span><br><span class="line">Message successfully delivered</span><br></pre></td></tr></table></figure></p>
<p>现在,你应该会收到你的第一条通知:<br><img src="http://o6jvfp7kw.bkt.clouddn.com/FirstPush-281x500.png" alt="FirstPush-281x500"></p>
<blockquote>
<p><strong>注意</strong> 如果你的App被打开并处于前台运行状态,你将看不到任何东西.通知已经被投送但是App还不会处理这个通知.你只需要简单的关闭App并重新发送通知即可.</p>
</blockquote>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>也许你会遇到以下问题:</p>
<p><strong>只能接收到部分通知</strong>:如果你同时发送多个通知,只有部分通知将会被接收,不用担心!这正是我们想要的结果.当发送通知时APNS会为每一个开启了推送通知的设备保持一个高质量服务(Quality of Service)队列.这个队列的大小是1,所以如果你同时发送多个通知,最后一个通知才会被发送.</p>
<p><strong>连接到APNS出现问题</strong>:出现这个问题的原因可能是你的防火墙阻塞了APNS所使用的端口.所以确保你的防火墙没有阻塞住这些端口.另一个可能的原因是私钥和CSR文件不正确.记住,每一个App ID有一个唯一的CSR和配对的私钥.</p>
<h1 id="解剖推送通知的基本原理"><a href="#解剖推送通知的基本原理" class="headerlink" title="解剖推送通知的基本原理"></a>解剖推送通知的基本原理</h1><p>在进行任务3之前,需要理解一下你推送的通知,打开 <strong>newspush.php</strong> 文件理解发送一个通知的基本概念应该是怎么样的.</p>
<p>注意第32-40行,这就是用JSON格式编码的装载体.这就是实际上发送给APNS的东西.在我们当前的例子中,装载体像下面一样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;aps&quot;:</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;alert&quot;: &quot;Breaking News!&quot;,</span><br><span class="line">    &quot;sound&quot;: &quot;default&quot;</span><br><span class="line">    &quot;link_url&quot; : &quot;https://raywenderlich.com,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于一个不懂JSON数据的人来说,用{}括起来的块相当于一个字典类型的数据.</p>
<p>这个装载体是一个至少包含一项内容的字典,这项内容就是 <strong>aps</strong>, 它本身也是一个字典.在这个例子中”aps”包含”alert”,”sound”和”link_url”等字段.当接收到一个通知,就会显示一个包含”Breaking News!”文本的提醒视图,并且有标准的提醒音效.</p>
<p>“link_url”实际上是一个自定义的字段.你可以添加类似的自定义字段到装载体中,并且它会被投送到你的应用.因为你并没有在应用中处理这个字段,所以当前接收到这个键值对会什么都不做.</p>
<p>你可以在aps字典中添加以下5个键(key):</p>
<ul>
<li><p>alert. 这个字段可以是一个字符串,就像当前的例子.或是是一个字典.如果是一个字典,可以是本地化的文本或者通知的其它部分.查看<a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/TheNotificationPayload.html#//apple_ref/doc/uid/TP40008194-CH107-SW1" target="_blank" rel="external">苹果文档</a>所支持的key.</p>
</li>
<li><p>badge. 这是一个将被显示在应用图标上的数字.你可以设置这个键为0来清除角标.</p>
</li>
<li><p>sound. 通过设置这个建,你可以播放存放在App本地定制的通知提示音来取代系统默认的通知提示音.定制的通知提示音必须在30秒以内并且还有一些其它的限制,你可以查看<a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/IPhoneOSClientImp.html#//apple_ref/doc/uid/TP40008194-CH103-SW6" target="_blank" rel="external">苹果文档</a>了解更详细信息.</p>
</li>
<li><p>content-available.设置这个键为1,当前通知会变成静默通知.这个部分会在这份教程的后面部分探索.</p>
</li>
<li><p>category. 这个键定义了通知的分类,用于显示定制通知所包含的交互行为.同样,接下来会探索这部分的内容.</p>
</li>
</ul>
<p>除此之外,你可以添加任意你想要添加的定制化数据,只要装载体不超过4096个字节.</p>
<p>如果你玩够了推送通知,接下来我们进入到下一个章节.</p>
<h1 id="处理接收到的通知"><a href="#处理接收到的通知" class="headerlink" title="处理接收到的通知"></a>处理接收到的通知</h1><p>在这个章节,你将会学习当App接收到通知后或者用户点击了通知应该如何执行什么样的操作.</p>
<h2 id="当你接收到一个通知后会发生什么"><a href="#当你接收到一个通知后会发生什么" class="headerlink" title="当你接收到一个通知后会发生什么"></a>当你接收到一个通知后会发生什么</h2><p>当你的App接收到一个通知, <em>UIApplicationDelegate</em> 的一个方法将会被调用.<br>需要根据接到收通知时App所处的状态的进行不同的处理.</p>
<ul>
<li><p>如果你的应用当前不在运行,并且用户通过点击推送通知启动应用,通知内容会通过 <em>application(_:didFinishLaunchingWithOptions:)</em> 方法的 <em>launchOptions</em> 参数进行传递.</p>
</li>
<li><p>如果你应用当前正运行在前台,推送通知将不会被显示.但是 <em>application(_:didReceiveRemoteNotification:)</em> 会被立即调用.</p>
</li>
<li><p>如果你的应用正在运行,或者被挂起在后台,并且用户通过点击通知使应用进入前台 <em>application(_:didReceiveRemoteNotification:)</em> 方法会被调用.</p>
</li>
</ul>
<p>在第一种情况下, WenderCast将到创建一个新的section,并直接打开以显示到这个新建section.添加以下代码到 <em>application(_:didFinishLaunchingWithOptions:)</em> 的末尾return语句之前.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Check if launched from notification</span><br><span class="line">// 1</span><br><span class="line">if let notification = launchOptions?[UIApplicationLaunchOptionsRemoteNotificationKey] as? [String: AnyObject] &#123;</span><br><span class="line">  // 2</span><br><span class="line">  let aps = notification[&quot;aps&quot;] as! [String: AnyObject]</span><br><span class="line">  createNewNewsItem(aps)</span><br><span class="line">  // 3</span><br><span class="line">  (window?.rootViewController as? UITabBarController)?.selectedIndex = 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码做了以下3件事:</p>
<ol>
<li><p>检查 <em>UIApplicationLaunchOptionsRemoteNotificationKey</em> 键对应的值是否存在,如果存在,这个值应该就是你发送的通知装载体.</p>
</li>
<li><p>如果存在,获取 <em>aps</em> 对应字典并传给 <em>createNewNewsItem(_:)</em> 方法,这个方法根据接收的字典创建一个 <em>NewItem</em>,并刷新表格.</p>
</li>
<li><p>改变tab控制器当前选中的tab索引值为1,也就是直接显示新闻控制器视图.</p>
</li>
</ol>
<p>为了测试这部分代码,你需要编辑WenderCast的scheme:<br><img src="http://o6jvfp7kw.bkt.clouddn.com/EditScheme.png" alt="EditScheme"></p>
<p>在 <strong>Run -&gt; Info</strong> 下选择 <strong>Wait for executable to be launched</strong>:<br><img src="http://o6jvfp7kw.bkt.clouddn.com/WaitForLaunch.png" alt="WaitForLaunch"></p>
<p>这个选项会使调试器等待应用程序安装直到应用程序第一次被启动。</p>
<p>编绎运行,完成安装后,发送一些新的动态.点击通知以启动App,启动之后App会显示一些新消息.<br><img src="http://o6jvfp7kw.bkt.clouddn.com/BuildAndRunFirstNews.png" alt="BuildAndRunFirstNews"></p>
<blockquote>
<p><strong>注意</strong> 如果你突然接收不到通知,最有可能的原因是device token被改了.如果你删除应用再重新安装就有可能出现这种情况. 确保你的device token是正确的.</p>
</blockquote>
<p>为了处理另外两种情况,添加以下代码到 <em>AppDelegate</em>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func application(application: UIApplication, didReceiveRemoteNotification userInfo: [NSObject : AnyObject]) &#123;</span><br><span class="line">  let aps = userInfo[&quot;aps&quot;] as! [String: AnyObject]</span><br><span class="line">  createNewNewsItem(aps)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法直接创建了一个新的 <em>NewsItem</em>. 现在你可以把scheme设置回自动启动App.</p>
<p>编绎运行.保持App运行在前台,并选中新闻页.发送一个通知,你可以看到消息奇迹般的显示在视线内.<br><img src="http://o6jvfp7kw.bkt.clouddn.com/NewNews-281x500.png" alt="NewNews-281x500"></p>
<p>就是这样!你的App现在可以处理基本的推送消息.</p>
<p>一些需要注意的事情:很多情况推送通知可能会被遗漏.对于WenderCast应用来说是没有问题的,因为装满消自己的列表对这个应用来说并不是那么重要,但是一般来讲你不应该把推送通知做为传递内容的唯一方式.作为备选项,推送通知应该仅仅只是指示当前有新的内容可以获取并让App从服务器下载这些新的内容.WenderCast应用在这方有一些局限性,因为它并没有合适的服务端.</p>
<h1 id="可交互的通知"><a href="#可交互的通知" class="headerlink" title="可交互的通知"></a>可交互的通知</h1><p>可交互的通知允许你添加定制化的按钮在通知上.你也许注意到邮件通知或者Twitter消息通知有一个让你回复或者点赞的部位.</p>
<p>可交互的通知是你通过注册通知时设置 <strong>categories</strong> 定义的.每一个通知分类都可以有多个预先自定义的交互.</p>
<p>一旦完成注册,就可以发送这个分类的通知.当接收到通知相应的交互就可以被用户获取.</p>
<p>对于 <strong>WenderCast</strong> 应用,你将定义一个自定义”View”动作的”News”分类,自定义”View”允许用户选择查看,如果用户选择就会在App中直接显示对应的消息详细文章.</p>
<p>添加以下代码到 <em>registerForPushNotifications(_:):</em> 的开头.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let viewAction = UIMutableUserNotificationAction()</span><br><span class="line">viewAction.identifier = &quot;VIEW_IDENTIFIER&quot;</span><br><span class="line">viewAction.title = &quot;View&quot;</span><br><span class="line">viewAction.activationMode = .Foreground</span><br></pre></td></tr></table></figure></p>
<p>这段代码创建了一个按钮标题名为”View”的新交互通知,当交互通知被用户触发时打开App并让其进入前台.这个交互动作的标识符是 <em>VIEW_IDENTIFIER</em> ,这个标识符被用于区分同一通知的不同交互动作.</p>
<p>添加以下人码片段至前面代码之后:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let newsCategory = UIMutableUserNotificationCategory()</span><br><span class="line">newsCategory.identifier = &quot;NEWS_CATEGORY&quot;</span><br><span class="line">newsCategory.setActions([viewAction], forContext: .Default)</span><br></pre></td></tr></table></figure></p>
<p>这段代码定义了一个新通知分类,设置交互动作为之前定义的”View”动作,设置标识符为” NEWS_CATEGORY”,这个标识符你是装载体要包含的内容以用其指示当前通知属于哪个分类.</p>
<p>最后,通过以下代码,把新建分类传递给UIUserNotificationSettings构造方法.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let notificationSettings = UIUserNotificationSettings(forTypes: [.Badge, .Sound, .Alert], categories: [newsCategory])</span><br></pre></td></tr></table></figure></p>
<p>编绎运行,应用会注册新通知设定.按Home键来退出当前应用,以使推送通知能够显示.</p>
<p>在你再次运行 <em>newspush.php</em> 之前,首先对指定的分类做一个改动.打开 <em>newspush.php</em> 修改通知装载体使它包含通知的分类标识符:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$body[&apos;aps&apos;] = array(</span><br><span class="line">  &apos;alert&apos; =&gt; $message,</span><br><span class="line">  &apos;sound&apos; =&gt; &apos;default&apos;,</span><br><span class="line">  &apos;link_url&apos; =&gt; $url,</span><br><span class="line">  &apos;category&apos; =&gt; &apos;NEWS_CATEGORY&apos;,</span><br><span class="line">  );</span><br></pre></td></tr></table></figure></p>
<p>保存并关闭newspush.php,然后运行以发送通知.如果一切进展顺利,你可以下拉并轻扫显示的通知你会看到View按钮被显示.<br><img src="http://o6jvfp7kw.bkt.clouddn.com/ViewAction-281x500.png" alt="ViewAction-281x500"><br>非常好,点击”View”按钮将启动WenderCast但不会做任何事情.为了获取通知装载体显示新的内容项,你需要在代理方法中做更多的操作.</p>
<h2 id="处理通知交互动作事件"><a href="#处理通知交互动作事件" class="headerlink" title="处理通知交互动作事件"></a>处理通知交互动作事件</h2><p>回到 <strong>AppDelegate.swift</strong>,添加另一个方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func application(application: UIApplication, handleActionWithIdentifier identifier: String?, forRemoteNotification userInfo: [NSObject : AnyObject], completionHandler: () -&gt; Void) &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let aps = userInfo[&quot;aps&quot;] as! [String: AnyObject]</span><br><span class="line"></span><br><span class="line">  // 2</span><br><span class="line">  if let newsItem = createNewNewsItem(aps) &#123;</span><br><span class="line">    (window?.rootViewController as? UITabBarController)?.selectedIndex = 1</span><br><span class="line"></span><br><span class="line">    // 3</span><br><span class="line">    if identifier == &quot;VIEW_IDENTIFIER&quot;, let url = NSURL(string: newsItem.link) &#123;</span><br><span class="line">      let safari = SFSafariViewController(URL: url)</span><br><span class="line">      window?.rootViewController?.presentViewController(safari, animated: true, completion: nil)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 4</span><br><span class="line">  completionHandler()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当用户通过通知的交互动作打开应用时这个方法将会被调用.这看来起好像做了很多事,但是实际上没有多少新的东西.这段代码做了以下事情:</p>
<ul>
<li>获取 <em>aps</em> 字典</li>
<li>根据获取到的字典创建 <em>NewItem</em> 并跳到新闻页.</li>
<li>检查以 <em>identifier</em> 为参数传进来的交互动作的标识符.如果View交互动作的标识符和链接有效则用 <em>SFSafariViewController</em> 显示这个链接内容.</li>
<li>在处理完用户交互动用之后调用系统传递给你的 <em>completionHandler</em> 回调.</li>
</ul>
<p>编绎运行,退出App,发送通知.但请确保下面的URL中有效的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ php newspush.php &apos;New Posts!&apos; &apos;https://raywenderlich.com&apos;</span><br></pre></td></tr></table></figure></p>
<p>点击通知的交互动作,在WenderCast应用启动后会立即展示Safari控制器.<br><img src="http://o6jvfp7kw.bkt.clouddn.com/SafariVC-281x500.png" alt="SafariVC-281x500"></p>
<p>恭喜,你刚刚已经完成了可交互通知的实现!尝试多发送几次通知,并用不同的方法打开通知观察通知的展现行为.</p>
<h1 id="静默推送通知"><a href="#静默推送通知" class="headerlink" title="静默推送通知"></a>静默推送通知</h1><p>静默推送通知可以静默方式的唤醒你的App并让它在后台执行任务.WenderCast可以利用这个特性悄悄地刷新播客列表.</p>
<p>正如你所想象的,配合合适的服务端这个功能会非常有用.你不需要不断的主动获取数据,当有数据可获取时仅仅只需要发送一个静默通知.</p>
<p>开始之前进入 <strong>App Settings -&gt; Capabilites</strong> 并打开 WenderCast的 <strong>Background Modes</strong>. 检查最后一个选项, <strong>Remote Notifications</strong> 是否勾选.<br><img src="http://o6jvfp7kw.bkt.clouddn.com/BackgroundModes.png" alt="BackgroundModes"></p>
<p>现在你的App接收到某个静默通知就可以在后台唤醒.</p>
<p>在AppDelegate内,用下面更强大的版本替换 <em>application(_:didReceiveRemoteNotification:)</em> 方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func application(application: UIApplication, didReceiveRemoteNotification userInfo: [NSObject : AnyObject], fetchCompletionHandler completionHandler: (UIBackgroundFetchResult) -&gt; Void) &#123;</span><br><span class="line">  let aps = userInfo[&quot;aps&quot;] as! [String: AnyObject]</span><br><span class="line"></span><br><span class="line">  // 1</span><br><span class="line">  if (aps[&quot;content-available&quot;] as? NSString)?.integerValue == 1 &#123;</span><br><span class="line">    // Refresh Podcast</span><br><span class="line">    // 2</span><br><span class="line">    let podcastStore = PodcastStore.sharedStore</span><br><span class="line">    podcastStore.refreshItems &#123; didLoadNewItems in</span><br><span class="line">      // 3</span><br><span class="line">      completionHandler(didLoadNewItems ? .NewData : .NoData)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else  &#123;</span><br><span class="line">    // News</span><br><span class="line">    // 4</span><br><span class="line">    createNewNewsItem(aps)</span><br><span class="line">    completionHandler(.NewData)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码:</p>
<ol>
<li>检查 <em>content-available</em> 是否为1,以确定是否是静默推送.</li>
<li>刷新播客列表,因为需要访问网络所以刷新列表是异步的.</li>
<li>当刷新完列表,调用 <em>completionHandler</em> 回调方法,让系统知道数据是否已经下载.</li>
<li>如果不是静默通知,假定它是消息并创建一个新的消息项.</li>
</ol>
<p>必需要确保 <em>completionHandler(_:)</em> 方法被调用并传递真实的是否获取到数据的结果.系统会根据回调计算耗电量和App在后台的时间,系统会根据需要调节App的耗电量以及在后台的时间.</p>
<p>以上就是这段代码所做的事.现在你可以用 <em>contentpush.php</em> 给你的应用发送一个静默通知.请务必确认以下设置脚本的正确性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Put your device token here (without spaces):</span><br><span class="line">$deviceToken = &apos;43e798c31a282d129a34d84472bbdd7632562ff0732b58a85a27c5d9fdf59b69&apos;;</span><br><span class="line"></span><br><span class="line">// Put your private key&apos;s passphrase here:</span><br><span class="line">$passphrase = &apos;WenderCastPush&apos;;</span><br></pre></td></tr></table></figure></p>
<p>在终端直接运行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ php contentpush.php</span><br></pre></td></tr></table></figure></p>
<p>如果一切顺利,什么事都不会发生.为了看到这段代码的运行结果,与之前设置的一样结果必须把scheme设置为”Wait for executable to be launched”并在 <em>application(_:didReceiveRemoteNotification:fetchCompletionHandler:)</em> 方法旁边打上断点,以确认这个方法会被调用.</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>恭喜你已经完成了这份推送通知教程的内容并且WenderCast应用也有全部的推送功能!</p>
<p>你可以在<a href="https://cdn2.raywenderlich.com/wp-content/uploads/2016/03/WenderCast-Final-1.1.zip" target="_blank" rel="external">这里</a>下载完整的工程.记住为了能让工程正常运行你仍然需要更改Bundle ID和证书.</p>
<p>推送通知功能对于现在的App已经是一个不可或缺的部分,但如果你发送的通知太频繁用户仍然会调整你的通知请求许可.对于一个深思熟虑的设计,推送通知会让你的应用保持足够的用户粘性!</p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/cat-1136365_1280-768x512.jpg" alt="cat-1136365_1280-768x512"></p>
<h2 id="这只猫接收到”推送通知”后它就知道晚餐已经准备好了"><a href="#这只猫接收到”推送通知”后它就知道晚餐已经准备好了" class="headerlink" title="这只猫接收到”推送通知”后它就知道晚餐已经准备好了"></a><em>这只猫接收到”推送通知”后它就知道晚餐已经准备好了</em></h2><p>我希望你能喜欢这份推送教程.如果你有任何问题,你可以在下面的评论中随意提问.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iPad横竖屏代码适配]]></title>
      <url>http://lemtter.com/2016/03/05/iPad%E6%A8%AA%E7%AB%96%E5%B1%8F%E4%BB%A3%E7%A0%81%E9%80%82%E9%85%8D/</url>
      <content type="html"><![CDATA[<p>你可能非常了解用不同的方式去适配不同尺寸的iPhone屏幕,在适配iPhone屏幕时你需要考虑的只是屏幕大小变化带来的UI元素间隔的变化,但是在iPad上主要针对的是横竖屏下完全不同的UI元素的布局,在这种情况下要考虑的就不仅仅是元素之间间隔这种问题了,除了要确保UI元素在这两种模式下的正确显示还要兼顾屏幕旋转的过渡动画.下图是QQZone For iPad 在横竖屏下的布局,可以看到横竖屏下菜单栏的布局方式差别很大.</p>
<p>QQZone for iPad <a href="https://github.com/JMStack/QQZone" target="_blank" rel="external">GitHub地址</a><br><a id="more"></a></p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/QQZone%E6%A8%AA%E5%B1%8F.PNG" alt="QQZone for iPad 竖屏"><br><img src="http://o6jvfp7kw.bkt.clouddn.com/QQZone%E7%AB%96%E5%B1%8F.PNG" alt="QQZone for iPad 横屏"></p>
<h2 id="屏幕适配的N种方法"><a href="#屏幕适配的N种方法" class="headerlink" title="屏幕适配的N种方法"></a>屏幕适配的N种方法</h2><p>无论iPad还是iPhone适配不同屏幕(尺寸,方向)的方式都跑不出以下几种,以下会一一对不同方式做一下简单的回顾.</p>
<h3 id="Autoresizing"><a href="#Autoresizing" class="headerlink" title="Autoresizing"></a>Autoresizing</h3><p>Autoresizing可以说是Autolayout始祖,Autoresizing的是一项比较有历史的技术了,其在iOS2的时代就推出了.当设置UIView实例对象的autoresizesSubviews属性为true(默认值为true),那么其子view会根据自已的autoresizingMask属性值自动调整与superview的位置和大小关系.autoresizingMask有六种可组合的使用的值,默认值是.None.这六种有效枚举值的意思如下:</p>
<ul>
<li>FlexibleLeftMargin   按比例跟随父控件变化的左间距</li>
<li>FlexibleWidth        按比例跟随交控件变化的宽度</li>
<li>FlexibleRightMargin  按比例跟随父控件变化的右间距</li>
<li>FlexibleTopMargin    按比例跟随父控件变化的顶部间距</li>
<li>FlexibleHeight       按比例跟随控件变化的高度</li>
<li>FlexibleBottomMargin 按比例跟随父控件变化的底部间距</li>
</ul>
<p>另外在xib,storyboard取消Autolayout时(Autoresizing与Autolayout相互冲突)可以在Size inspector可以更加直观地按需求进行组和使用.Autoresizing技术在一定应用场景下可以勉强使用但应对更为精细的布局就无能为力了,你可以在使用Autoresizing同时重写layoutSubviews方法去做更为精细的布局,尽管如此但还是不推荐这么做,因为同时得写layoutSubviews和使用Autoresizing去布局会让你的布局逻辑变得不清晰,这将给后期的维护带来麻烦.</p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/SizecClass.png" alt="Autoresizing in storyboard"></p>
<h3 id="Autolayout"><a href="#Autolayout" class="headerlink" title="Autolayout"></a>Autolayout</h3><p>Autolayout是iOS6时代引入的技术,专门用来处理不同屏幕尺寸下的UI布局.从Xcode6开始Autolayout配合xib,storyboard极大的提高屏幕的适配工作效率.在一定程度上甚至可以完全摆脱设置frame布局的方式.由于storyboard,xib在多人合作开发冲突不断的尴尬境地,在实际的开发中多使用第三方框架用代码进行Autolayout布局.这样既避免了解决冲突麻烦又享受到了Autolayout带来的宏利.比较受欢迎的Autolayout每三方框架有<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">Masonry</a>还有<a href="http://weibo.com/gsdios?profile_ftype=1&amp;is_all=1#_0" target="_blank" rel="external">GSD_iOS</a>大神的<a href="https://github.com/gsdios/SDAutoLayout" target="_blank" rel="external">SDAutoLayout</a></p>
<p>尽管Autolayout有很多好处但还是很多代码党不愿使用,究其原因还是约束.约束的问题大至可以分约束冲突和约束不满足两大类,当在storyboard中对一个复杂的界面进行Autolayout约束,一但出现问题将很难排查,用代码行约束往往程序运行起来才能确认约束是否满足条件,同样排查起来也不是那么方便.关于Autolayout这不再占用过多的篇幅,网上有相当多的资料可供参考.</p>
<h3 id="SizeClass"><a href="#SizeClass" class="headerlink" title="SizeClass"></a>SizeClass</h3><p>SizeClass是要配合Autolayout使用的,SizeClass实际上是对屏幕尺寸的抽象,把屏幕宽高分成Compact:紧凑、Regular:宽松、Any:任意三种类型这样就可以组合出九种不同的屏幕类型.在storyboard,xib编辑界面下最下方可以选择某一约束在只在某一类屏幕下生效.这样可以在不同屏幕下得到不同的UI布局效果.关于SizeClass的使用可以参考<a href="https://www.raywenderlich.com/113768/adaptive-layout-tutorial-in-ios-9-getting-started" target="_blank" rel="external">raywenderlich</a>系例文章.</p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/AutoLayout.png" alt="SizeClass"></p>
<h3 id="代码计算坐标"><a href="#代码计算坐标" class="headerlink" title="代码计算坐标"></a>代码计算坐标</h3><p>在所有的布局方法中这种可能是最费体力的一项,因为所有的UI元素都需要一个一个明确的计算或者指定出来.尽管如此正因为每个元素的frame是手动计算因此灵活性也非常大你可以随心所欲的计算每个控件的frame,出现问题时也非常好排查.如果需要动态的改变view的frame就需要重写父控件的layoutSubviews方法,在重写的layoutSubviews明确计算出frame. 如果view是固定的则只需要在添加到父控件时指定view的frame.一般常见的代码布局形式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override func layoutSubviews() &#123;</span><br><span class="line">    super.layoutSubviews()</span><br><span class="line">    let x: CGFloat = 0</span><br><span class="line">    let y: CGFloat = frame.height * 0.7 // 根据父控件高度按比例确定y座标</span><br><span class="line">    let w: CGFloat = frame.width</span><br><span class="line">    let h: CGFloat = frame.height - y  // 根据父控件高度,子控件按比例调整高度</span><br><span class="line">    subView.frame = CGRectMake(x, y, w, h)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是常见的根据父控件动态调整子控件frame的形式,真实开发中可能还需要考虑横竖屏下动态的布局(下面将提到的),以上基本形式可以根据需求进行扩展.当然你也可以不用重写layoutSubviews方法而在需要改变frame的时机显式直接改变frame,但在这种方式并不符合苹果的逻辑.在view的层次结构中某一view肯定是有superview的,而子view是否变化,以及什么时候变化应是由superview来决定的,在一个多层次结构的view视图中如果显示的设定子view的frame那你不得不根据view的层次结构一级一级的设置子view的frame.superview和subView之前会出现较强的关联性.理想情况下一个superview应该只关注自身的subView的布局,无论这个superview的frame或层次结构怎么变化其subviews并不需要知道.因此我觉得比较好的做法是有所关于subviews的frame的设定都应该重写layoutSubviews,在layoutSubviews中去做.这样做的另一个好处是屏幕旋转时你并不需要显示的去写UIView动画.</p>
<h2 id="layoutsubviews的调用时机"><a href="#layoutsubviews的调用时机" class="headerlink" title="layoutsubviews的调用时机"></a>layoutsubviews的调用时机</h2><p>用代码在layoutSubviews中布局你必需要知道系统会在哪些时机去调用layoutsubviews函数.关于这个问题的结论可以参看<a href="http://stackoverflow.com/questions/728372/when-is-layoutsubviews-called" target="_blank" rel="external">stackoverflow</a>的讨论.关于这个问题我个人比较赞同第二个回答者对第一个回答的纠正.基本上layoutsubviews会在以下几种情况下调用:</p>
<ul>
<li>当view的bounds发生改变时</li>
<li>当view的直接subView的bounds发生改变时</li>
<li>当subView添加或移除时</li>
<li>调用setNeedsLayout方法会在下一个显示周期主动调用layoutsubviews</li>
</ul>
<h2 id="如何获取当前屏幕方向"><a href="#如何获取当前屏幕方向" class="headerlink" title="如何获取当前屏幕方向"></a>如何获取当前屏幕方向</h2><p>关于获取当前屏幕方向我所知道的方法仅包括以下几种:</p>
<ul>
<li>通过控制器的interfaceOrientation只读属性获取,<strong>iOS8后过期</strong></li>
<li>能过状态栏的方向间接获取,UIApplication的只读属性statusBarOrientation,<strong>iOS9后过期</strong></li>
<li>能过UIDevice只读属性orientation获取.需主动调用beginGeneratingDeviceOrientationNotifications开启通知</li>
<li>通过根控制器的view宽高推导获取,当高&gt;宽为竖屏否则为横屏</li>
</ul>
<h2 id="Demo预览"><a href="#Demo预览" class="headerlink" title="Demo预览"></a>Demo预览</h2><p>下面是这个Demo的最终效果,我将通个下面的例子记录我认为合理的代码适配横竖屏的方式.</p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/QQZone%E9%A2%84%E8%A7%88-Slow.gif" alt="Demo预览慢速"><br><img src="http://o6jvfp7kw.bkt.clouddn.com/QQZone%E9%A2%84%E8%A7%88.gif" alt="Demo预览正常"></p>
<h2 id="Demo分析"><a href="#Demo分析" class="headerlink" title="Demo分析"></a>Demo分析</h2><p>上面一些基础的知识将有助于理解Demo的做法,所以尽管有一点废话连篇的感觉好在也并不是一无是处.在讲解Demo的实现思路之前你可以在<a href="https://github.com/JMStack/QQZone" target="_blank" rel="external">GitHub</a>下载这个Demo,以便更方便的查看我讲到的代码.</p>
<p>Demo中最复杂的,横竖屏布局变化最大的部分就是左侧的菜单栏可以称它为Dock栏,通过旋转屏幕可以看到原生QQZone HD的Dock栏的变化.可以根据变化的特征将整个Dock栏分为三部分.一是顶部的头像 二是中间的类TabBar,我称它为TabBar 三是 底部的快捷导航菜单.因此DockView的subview包含iconButton,tabBarView,menuBar三个,而这三个subview又可以分另包含各自的子控件.</p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/Demo%E8%A7%86%E5%9B%BE%E7%BB%93%E6%9E%84.png" alt="view层次结构"></p>
<p>实际上实现QQZone for iPad屏幕的横竖屏的布局并不复杂.一个view要知道怎样在layoutSubviews中去布局其子view只需知道当前其superview的状态(横竖屏).在这里我声明了一个协议,这个协议只包含一个获取当前view是否是竖屏的方法.让每一个需要根据横竖屏动态变化的view都实现这个协议的方法,这样在layoutSubviews方法就可以询问当前应该怎么样布局子控件而当前状态是由父控件状态决定的.由此形成了屏幕状态的传递链,使得每个veiw只关心自身直接subview的布局.<br><figure class="highlight plain"><figcaption><span>UIViewisPortrait协议</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol UIViewisPortrait: NSObjectProtocol &#123;</span><br><span class="line">    func isPortrait() -&gt; Bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根控制器view的任意subview可都可以通过如下代码获取当前是否是竖屏<br><figure class="highlight plain"><figcaption><span>subview 如何获取superview状态</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func isPortrait() -&gt; Bool &#123;</span><br><span class="line">    guard let superview = superview else &#123; // 如果不存大superview默认返回竖屏</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    return ((superview as? UIViewisPortrait)?.isPortrait())!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而根控制器view则直接通过宽高获取屏幕状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func isPortrait() -&gt; Bool &#123;</span><br><span class="line">    return frame.width &lt; frame.height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当前view知道是横竖屏后就可以直接在layoutsubviews布局子控件了,以menuBar为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">override func layoutSubviews() &#123;</span><br><span class="line">    super.layoutSubviews()</span><br><span class="line">    guard subviews.count &gt; 0 else &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var x, y, w, h:CGFloat</span><br><span class="line">    for (index, view) in subviews.enumerate() &#123;</span><br><span class="line">        if isPortrait() == true &#123;</span><br><span class="line">            w = frame.width</span><br><span class="line">            h = kDockItemHeight</span><br><span class="line">            x = 0</span><br><span class="line">            y = CGFloat(index) * h</span><br><span class="line">            view.frame = CGRect(x: x, y: y, width: w, height: h)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            w = frame.width / CGFloat(subviews.count)</span><br><span class="line">            h = kDockItemHeight</span><br><span class="line">            x = CGFloat(index) * w</span><br><span class="line">            y = frame.height - h</span><br><span class="line">            view.frame = CGRect(x: x, y: y, width: w, height: h)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其它类型的所有子控件都可以用类似的方法进行布局,如此你只需要定义一个view并始之成为某个View的subview,在你定义的view中你可以随意的获取屏幕状态布局子控件了.</p>
<p>为了在根控制器View的layoutSubviewsr的方法中布局DockView,需要重写控制器的loadView方法,让控制器加载自定义的View. 如果你注意到原生QQZone for iPad的内容显示区域在横竖屏下的变化会发现在横坚屏下内容显示区域宽都是一样的,所以还需要在根控制器View中添加一个容器View以显示内容.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class HomePageView: UIView, UIViewisPortrait &#123;</span><br><span class="line">    private lazy var dockView:DockView = DockView()</span><br><span class="line"></span><br><span class="line">    lazy var contentView: UIView = &#123;</span><br><span class="line">        let contentView = UIView()</span><br><span class="line">        contentView.backgroundColor = UIColor.whiteColor()</span><br><span class="line">        // 作为容器View,子控制器的view将添加到容器view上</span><br><span class="line">        self.addSubview(contentView)</span><br><span class="line">        return contentView</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    func isPortrait() -&gt; Bool &#123;</span><br><span class="line">        return frame.width &lt; frame.height</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override init(frame: CGRect) &#123;</span><br><span class="line">        super.init(frame: frame)</span><br><span class="line">        addSubview(dockView)</span><br><span class="line">        dockView.backgroundColor = globalBackgroudColor</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    required init?(coder aDecoder: NSCoder) &#123;</span><br><span class="line">        fatalError(&quot;init(coder:) has not been implemented&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override func layoutSubviews() &#123;</span><br><span class="line">        super.layoutSubviews()</span><br><span class="line">        dockView.frame.size.height = frame.height</span><br><span class="line">        dockView.frame.size.width = isPortrait() ? kDockProtraitWidth : kDockLandscapeWidth</span><br><span class="line"></span><br><span class="line">        let x: CGFloat = dockView.frame.width</span><br><span class="line">        let y: CGFloat = 20</span><br><span class="line">        // 无论横竖屏,内容视图的宽都一样</span><br><span class="line">        let w: CGFloat = min(frame.width, frame.height) - kDockProtraitWidth</span><br><span class="line">        let h: CGFloat = frame.height - y</span><br><span class="line"></span><br><span class="line">        contentView.frame = CGRectMake(x, y, w, h)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后由于内容区域不用区分横竖屏,因此内容区域的子视图可以只考虑竖屏的情况,以上可以说得不是很清楚,如果感觉有兴趣可<a href="https://github.com/JMStack/QQZone" target="_blank" rel="external">下载</a>原码参阅.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上重点仅仅是用代码进行iPad横竖屏适配方法的探讨,这里只是记录了我认为较为合理的方法,当然这种方法可能并不适用所有的布局,毕竟每个App都有自己独特的UI部分.如果觉得这种方法不好欢迎指出,我将虚心请教.如果这个方法对你的业务提供了一点点的灵感希望点个赞,以上完.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[React Native的开发环境配置]]></title>
      <url>http://lemtter.com/2016/02/27/React-Native%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h1 id="一、环境需求"><a href="#一、环境需求" class="headerlink" title="一、环境需求"></a>一、环境需求</h1><h2 id="1-1-安装Homebrew"><a href="#1-1-安装Homebrew" class="headerlink" title="1.1  安装Homebrew"></a>1.1  安装Homebrew</h2><p>Homebrew是OS X的套件(包)管理器，我们可以通过它获取并且安装很多组件<br>安装方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>
<p>##1.2  安装npm 和 Node.js<br>Node.js最好安装4.0及其以上更高版本，node安装成功后npm自动也就有了，直接下载安装Node.js<br><a href="https://nodejs.org/en/download/" target="_blank" rel="external">https://nodejs.org/en/download/</a></p>
<h2 id="1-3-安装WatchMan"><a href="#1-3-安装WatchMan" class="headerlink" title="1.3  安装WatchMan"></a>1.3  安装WatchMan</h2><p>该插件用于监控bug文件和文件变化 ，并且可以触发指定的操作<br>安装方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install watchman</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>验证是否安装成功<br><img src="http://upload-images.jianshu.io/upload_images/659811-21834d9f29755f4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160527_2.png"></p>
<h2 id="1-3-安装Flowflow是一个-JavaScript-的静态类型检查器，建议安装它，以方便找出代码中可能存在的类型错误"><a href="#1-3-安装Flowflow是一个-JavaScript-的静态类型检查器，建议安装它，以方便找出代码中可能存在的类型错误" class="headerlink" title="1.3  安装Flowflow是一个 JavaScript 的静态类型检查器，建议安装它，以方便找出代码中可能存在的类型错误"></a>1.3  安装Flowflow是一个 JavaScript 的静态类型检查器，建议安装它，以方便找出代码中可能存在的类型错误</h2><p>安装方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install flow</span><br></pre></td></tr></table></figure></p>
<p>验证是否安装成功<br><img src="http://upload-images.jianshu.io/upload_images/659811-f4b70b69c937286b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160527_3.png"></p>
<p>(注意：如果提示command not found,请加上sudo获得最高权限)</p>
<h1 id="二、React-Native安装"><a href="#二、React-Native安装" class="headerlink" title="二、React Native安装"></a>二、React Native安装</h1><h2 id="2-1-安装React-Native"><a href="#2-1-安装React-Native" class="headerlink" title="2.1 安装React Native"></a>2.1 安装React Native</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g react-native-cli</span><br></pre></td></tr></table></figure>
<h2 id="2-2-安装截图如下"><a href="#2-2-安装截图如下" class="headerlink" title="2.2 安装截图如下:"></a>2.2 安装截图如下:</h2><p><img src="http://upload-images.jianshu.io/upload_images/659811-fc9357d144343442.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160527_4.png"></p>
<h1 id="三、-ios开发环境需求"><a href="#三、-ios开发环境需求" class="headerlink" title="三、 ios开发环境需求"></a>三、 ios开发环境需求</h1><p>Xcode 7 及其以上更高版本</p>
<h1 id="四、-Android开发环境需求"><a href="#四、-Android开发环境需求" class="headerlink" title="四、 Android开发环境需求"></a>四、 Android开发环境需求</h1><p>安装最新版的JDK:</p>
<p>下载安装地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a><br>可以安装Android studio省略此步骤，建议安装Android studio。</p>
<h2 id="4-1-安装Genymotion"><a href="#4-1-安装Genymotion" class="headerlink" title="4.1  安装Genymotion"></a>4.1  安装Genymotion</h2><p>Genymotion是一个第三方模拟器，它比Google官方的模拟器更易设置且性能更好。但是，它只针对个人用户免费。</p>
<ol>
<li>下载并安装Genymotion<br>   <a href="https://www.genymotion.com/" target="_blank" rel="external">https://www.genymotion.com/</a></li>
<li>打开Genymotion,如果你尚未安装VirtualBox,它有可能会提示你安装</li>
<li>创建一个模拟器并启动</li>
<li>按下⌘+M可以打开开发者菜单(在安装并启动了React Native应用之后)</li>
</ol>
<h1 id="五、-React-Native的第一个应用"><a href="#五、-React-Native的第一个应用" class="headerlink" title="五、 React Native的第一个应用"></a>五、 React Native的第一个应用</h1><h2 id="5-1-执行命令-生成一个工程"><a href="#5-1-执行命令-生成一个工程" class="headerlink" title="5.1 执行命令,生成一个工程"></a>5.1 执行命令,生成一个工程</h2><p>react-native init 项目名称<br>注意:由于众所周知的网络原因，需要等待一段时间（具体视网络情况而定）。react-native命令行从npm官方源拖代码时会遇上麻烦，可以将npm仓库源替换为国内镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line">npm config set disturl https://npm.taobao.org/dist</span><br></pre></td></tr></table></figure></p>
<h2 id="5-2-运行截图"><a href="#5-2-运行截图" class="headerlink" title="5.2  运行截图"></a>5.2  运行截图</h2><p><img src="http://upload-images.jianshu.io/upload_images/659811-b69551fa6192565d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160527_7.png"></p>
<h2 id="5-3-目录结构截图"><a href="#5-3-目录结构截图" class="headerlink" title="5.3 目录结构截图"></a>5.3 目录结构截图</h2><p>目录结构分析:</p>
<ol>
<li>默认生成android和ios两个平台的原生项目；</li>
<li>其中，index.android.js和index.ios.js文件为Android和iOS的空壳应用文件；</li>
<li>此外，node_modules文件夹，是为Node.js存放和管理npm包资源，也包含React Native框架文件。</li>
</ol>
<p>查看index.ios.js中的代码:<br><img src="http://upload-images.jianshu.io/upload_images/659811-ed01bcde5e3b132e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160528_8.png"></p>
<h1 id="六、运行工程文件"><a href="#六、运行工程文件" class="headerlink" title="六、运行工程文件"></a>六、运行工程文件</h1><p>不管是 iOS 还是 Android，在开发调试阶段，都需要在 Mac 上启动一个 HTTP 服务，称为Debug Server，默认运行在 8081 端口，APP 通 Debug Server 加载 js。</p>
<h2 id="6-1-打开Xcode，运行你的第一个React-Native创建的iOS应用"><a href="#6-1-打开Xcode，运行你的第一个React-Native创建的iOS应用" class="headerlink" title="6.1 打开Xcode，运行你的第一个React Native创建的iOS应用"></a>6.1 打开Xcode，运行你的第一个React Native创建的iOS应用</h2><p>图1 - 启动React native 服务器<br>m</p>
<p>图2 - 客户端运行界面</p>
<h2 id="6-2-把React-Native创建的应用跑在Android上"><a href="#6-2-把React-Native创建的应用跑在Android上" class="headerlink" title="6.2 把React Native创建的应用跑在Android上"></a>6.2 把React Native创建的应用跑在Android上</h2><ol>
<li>命令行执行cd SeeMyGoProduct,路径切换到项目主目录</li>
<li>命令行执行react-native run-android进行加载运行android 应用。</li>
<li>使用编辑器进行打开和修改index.android.js文件，接着通过菜单按钮选择Reload JS来进行刷新修改</li>
</ol>
<h1 id="七、管理React-Native库的版本"><a href="#七、管理React-Native库的版本" class="headerlink" title="七、管理React Native库的版本"></a>七、管理React Native库的版本</h1><p>在开发中，会经常的去控制React Native的版本库，得以适配各种条件下的开发，那该如何查看、控制ReactNative的版本呢？</p>
<h2 id="7-1-查看本地的React-Native的版本"><a href="#7-1-查看本地的React-Native的版本" class="headerlink" title="7.1 查看本地的React Native的版本"></a>7.1 查看本地的React Native的版本</h2><p>命令行输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native --version</span><br></pre></td></tr></table></figure></p>
<p>命令行效果</p>
<h2 id="7-2-更新本地的React-Native的版本"><a href="#7-2-更新本地的React-Native的版本" class="headerlink" title="7.2 更新本地的React Native的版本"></a>7.2 更新本地的React Native的版本</h2><p>命令行输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update -g react-native-cli</span><br></pre></td></tr></table></figure></p>
<h2 id="7-3-查询react-native的npm包最新版本"><a href="#7-3-查询react-native的npm包最新版本" class="headerlink" title="7.3 查询react-native的npm包最新版本"></a>7.3 查询react-native的npm包最新版本</h2><p>NPM的全称是Node Package Manager ，是一个NodeJS包管理和分发工具，已经成为了非官方的发布Node模块（包）的标准。<br>npm包地址 ：<a href="https://www.npmjs.com/package/react-native" target="_blank" rel="external">https://www.npmjs.com/package/react-native</a><br>命令行查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm info react-native</span><br></pre></td></tr></table></figure></p>
<p>查询效果</p>
<p>项目中查看</p>
<h2 id="7-4-升级或者降级npm包的版本"><a href="#7-4-升级或者降级npm包的版本" class="headerlink" title="7.4 升级或者降级npm包的版本"></a>7.4 升级或者降级npm包的版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react-native@0.18</span><br></pre></td></tr></table></figure>
<h2 id="7-5-更新项目templates文件（可选）"><a href="#7-5-更新项目templates文件（可选）" class="headerlink" title="7.5 更新项目templates文件（可选）"></a>7.5 更新项目templates文件（可选）</h2><p>新的npm包会包含更新在运行react-native init命令生成的一些动态文件，例如init创建项目的时候会生成iOS和Android的子项目，我们可以通过以下的命令进行获取最新的代码<br>命令行查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native upgrade</span><br></pre></td></tr></table></figure></p>
<h1 id="八、WebStom设置React-Native代码提示"><a href="#八、WebStom设置React-Native代码提示" class="headerlink" title="八、WebStom设置React Native代码提示"></a>八、WebStom设置React Native代码提示</h1><h2 id="8-1-从gitHub上下载xml插件"><a href="#8-1-从gitHub上下载xml插件" class="headerlink" title="8.1  从gitHub上下载xml插件"></a>8.1  从gitHub上下载xml插件</h2><pre><code>git clone https://github.com/virtoolswebplayer/ReactNative-LiveTemplate
</code></pre><h2 id="8-2-安装"><a href="#8-2-安装" class="headerlink" title="8.2  安装"></a>8.2  安装</h2><p>将ReactNative.xml复制到 ~/Library/Preferences/WebStorm10/templates ，然后重启 WebStrom</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微博,微信图片浏览过渡动画的实现]]></title>
      <url>http://lemtter.com/2016/02/02/%E5%BE%AE%E5%8D%9A-%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E6%B5%8F%E8%A7%88%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>大家在平常用微信,微博的过程中肯定(对,就是肯定)都有查看过朋友圈和微博所发布的照片,当点击九宫格的某一图片时图片会慢慢的放大并进入全屏,左右滑动查看另一张.轻点图片又会以动画的方式慢慢缩小回到滑动之后对应的图片.说了这么多估计你还是不知道我在讲什么鬼,一张动图胜过千言万语.毕竟语言这东西真不是码农的特长…</p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/%E5%BE%AE%E5%8D%9A%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%9B%BE.gif" alt="微博九宫格"><br><a id="more"></a><br><img src="http://o6jvfp7kw.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E4%B9%9D%E5%AE%AB%E6%A0%BC.gif" alt="微信九宫格"></p>
<p>上面两张gif点开时的动画不是很明显,你可以在真机上查看更真实效果.接下来我会通过一个Demo来介绍实现这种效果的具体思路,如果你有更好的思路,请求赐教</p>
<hr>
<h1 id="Demo-预览"><a href="#Demo-预览" class="headerlink" title="Demo 预览"></a>Demo 预览</h1><p>在开始之前先看一看最终的效果</p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/Demo%E9%A2%84%E8%A7%88.gif" alt="Demo 预览"></p>
<p>这个Demo抓取了<a href="http://www.meilishuo.com" target="_blank" rel="external">美丽说</a>的在线图片,这里对毫不知情的美丽说表示感谢.<br>在看下面的部分之前假定你已经撑握了Swift,网络请求,会使用UICollectionView等基础组件的技能.如若不能撑握建议先了解相关知识</p>
<p><em>Demo<a href="https://github.com/JMStack/PhotoBrowse.git" target="_blank" rel="external">GitHub地址</a></em></p>
<h1 id="Demo-结构分析"><a href="#Demo-结构分析" class="headerlink" title="Demo 结构分析"></a>Demo 结构分析</h1><p>在Demo中主要包括两个主要的视图结构:一 缩略图(主视图)的浏览 二 大图的浏览. 这两个视图中所要展示的内容都是有规律的矩形所以都可以用UICollectionView来实现.<br>两者的区别在于缩略图是垂直方向的布局而大图是水平方向上的布局方式.两个UICollectionView的cell的内容只包含一个UIImageView.在大图浏览视图中有一个<br>需要注意的细节:为了图片浏览的效果每张图片之间是有一定间隔的,如果让每个cell都填充整个屏幕,图片的宽度等于cell的宽度再去设置cell的间隔来达到间隔的效果会在停止滑动图片时黑色的间隔会显现在屏幕中(如下图),这并不是我们想看到的结果.</p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/%E9%94%99%E8%AF%AF%E7%9A%84%E5%A4%A7%E5%9B%BEcell%E5%AE%BD%E8%AE%BE%E7%BD%AE.png" alt="错误的大图cell宽设置"></p>
<p>出现这个问题的原因是UICollectionView的分页(pagingEnabled)效果是以UICollectionView的宽来滚动的,也就是说不管你的cell有多大每次滚动总是一个UICollectionView自身的宽.要实现这个效果有个小技巧,相关内容会在<strong>大图浏览的实现</strong>一节中介绍.</p>
<h1 id="主视图图片浏览的实现"><a href="#主视图图片浏览的实现" class="headerlink" title="主视图图片浏览的实现"></a>主视图图片浏览的实现</h1><p>根据上一节得出的结论,主视图采用colletionview,这部分实现没什么特别的技巧,但在添加collectionview之前需要添加几个基础组件.<br>因为我们所需的图片是抓取美丽说的网络图片,所以我们需要一个网络请求组件,另外为展示图片还需要添加对应的数据模型.但这两个组件的内容不是本篇博文主要讨论的问题<br>另外这两个组件相对较基础,就不废太多口水.具体实现可以参看<a href="https://github.com/JMStack/PhotoBrowse.git" target="_blank" rel="external">GitHub</a>源码,每次网络请求这里设置为30条数据,这里提到也是为了让你在下面的章节看到相关部分不至于感到疑惑,<br>添加完这两个基础组件之后,就可以实现缩略图的浏览部分了.为方便起见缩略图view的控制器采用UICollectionViewController,在viewDidLoad函数中设置流水布局样式,实现collectionview的datasource,delegate.这部分都是一些常规的写法,这里要关注的是datasource和delegate的下两个函数.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">override func collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -&gt; UICollectionViewCell &#123;</span><br><span class="line">    // 从缓存池中取出重用cell</span><br><span class="line">    let cell = collectionView.dequeueReusableCellWithReuseIdentifier(reuseIdentifier, forIndexPath: indexPath) as? CollectionViewCell</span><br><span class="line">    // 从模形数组中取出相应的模形</span><br><span class="line">    let item = shopitems[indexPath.item];</span><br><span class="line">    // 设置模形数据为显示缩略图模式</span><br><span class="line">    item.showBigImage = false</span><br><span class="line">    // 把模形数据赋值给cell,由cell去决定怎样显示,显示什么内容</span><br><span class="line">    cell?.item = item</span><br><span class="line">    // 当滑动到到最后一个cell时请求加载30个数据</span><br><span class="line">    if indexPath.item == shopitems.count - 1 &#123;</span><br><span class="line">        loadMoreHomePageData(shopitems.count)</span><br><span class="line">    &#125;</span><br><span class="line">    return cell!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里为使Demo不过于复杂,没有用什么”上拉加载更多”控件,每次滑动到到最后一个cell时请求加载30个数据方式同样能获得良好的滑动体验</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">override func collectionView(collectionView: UICollectionView, didSelectItemAtIndexPath indexPath: NSIndexPath) &#123;</span><br><span class="line">    // 当点击某个cell时, 创建大图浏览控制器</span><br><span class="line">    let photoVC = PhotoBrowseCollectionVC()</span><br><span class="line">    // 当前点击cell的indexPathw传给控制器,以使大图浏览器直接显示对应图片</span><br><span class="line">    photoVC.indexPath = indexPath</span><br><span class="line">    // 当前模型数组的内容传给控制器,以使大图浏览能左右滑动</span><br><span class="line">    photoVC.items = shopitems</span><br><span class="line">    // 先以正常形式modal出大图浏览</span><br><span class="line">    presentViewController(photoVC, animated: true, completion: nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先以正常的样式(从底部弹出)modal出大图浏览视图,当缩略图和大图的逻辑跳转逻辑完成后再来完善画动逻辑</p>
<h1 id="大图浏览的实现"><a href="#大图浏览的实现" class="headerlink" title="大图浏览的实现"></a>大图浏览的实现</h1><p>与缩略图一样,大图浏览也是一个collectionView.这里为大图浏览控制器添加了一个<a href="http://wiki.jikexueyuan.com/project/swift/chapter2/14_Initialization.html" target="_blank" rel="external">便利构造器</a>,以便在点击缩略图时快速创建固定流水布局的collectionView.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">convenience init() &#123;</span><br><span class="line">        let layout = UICollectionViewFlowLayout()</span><br><span class="line">        layout.itemSize = CGSize(width: UIScreen.mainScreen().bounds.width + cellMargin, height: UIScreen.mainScreen().bounds.height)</span><br><span class="line">        layout.minimumLineSpacing = 0</span><br><span class="line">        layout.minimumInteritemSpacing = 0</span><br><span class="line">        layout.scrollDirection = .Horizontal</span><br><span class="line">        self.init(collectionViewLayout: layout)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在<strong>Demo 结构分析</strong>一节中遗留了一个问题,其实要实现全屏图像间隔效果非常简单,只要把collectionView和cell的宽设置为屏宽加固定的间距并且cell之间间距为0<br>而图片只显示在屏幕正中间(图片与屏等宽),这样在开启pagingEnabled的情况下每次滑动都是滑动一个(图片宽度+间距),相当于在cell中留了一个边距来作间隔而不是在cell<br>外做间隔,可以参看下图</p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/%E5%9B%BE%E7%89%87%E9%97%B4%E9%9A%94%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt=""></p>
<p>上图中有两个cell,cell的间距是零.开启pagingEnabled时,每次移动都是一个cell的宽,这样停止滑动时间隔就不会出现在屏幕中了.<br>大图浏览的collectionView的实现代码几乎与缩略图一样,需要注意的是当modal出大图的时候collectionView是要直接显示对应大图的,这也是为什么在缩略视图控制器的didSelectItemAtIndexPath函数中要传递indexPath的原因.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    // 大图colletionview的frame</span><br><span class="line">    collectionView?.frame = UIScreen.mainScreen().bounds</span><br><span class="line">    collectionView?.frame.size.width = UIScreen.mainScreen().bounds.size.width + cellMargin</span><br><span class="line">    // 开启分页</span><br><span class="line">    collectionView?.pagingEnabled = true</span><br><span class="line">    // 注册重用cell</span><br><span class="line">    collectionView?.registerClass(CollectionViewCell.self, forCellWithReuseIdentifier: cellID)</span><br><span class="line">    // collectionView显示时跳转到应的图片</span><br><span class="line">    collectionView?.scrollToItemAtIndexPath(indexPath!, atScrollPosition: .Left, animated: false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中scrollToItemAtIndexPath函数的atScrollPosition参数的意思是停止滚动时对应的cell与collectionView的位置关系,Left是cell的左边与colletionview的<br>左边对齐.其它的对应关系可依此类推就不废话了. collectionView的比较重要代理函数的实现如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">override func collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -&gt; UICollectionViewCell &#123;</span><br><span class="line">    let cell = collectionView.dequeueReusableCellWithReuseIdentifier(cellID, forIndexPath: indexPath) as! CollectionViewCell</span><br><span class="line"></span><br><span class="line">    let item = items![indexPath.item]</span><br><span class="line">    item.showBigImage = true</span><br><span class="line">    cell.item = item</span><br><span class="line"></span><br><span class="line">    return cell</span><br><span class="line">&#125;</span><br><span class="line">override func collectionView(collectionView: UICollectionView, didSelectItemAtIndexPath indexPath: NSIndexPath) &#123;</span><br><span class="line">    dismissViewControllerAnimated(true, completion: nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>说重要是因为要与缩略图控制器的代理函数对比看,cellForItemAtIndexPath只是常规的设置数据,选中cell直接dismiss当前控制器.<br>至此缩略图和大图的跳转逻辑你已经清楚了,下面的部分才本博文要讲的真正内容.其实上面分析那么多废话也是因为present和dismiss的动画与跳转前后两个控制器有密切关系</p>
<h1 id="modal出一个View的原理"><a href="#modal出一个View的原理" class="headerlink" title="modal出一个View的原理"></a>modal出一个View的原理</h1><p>默认从底部弹出view的modal方式是将要显式的view添加到一个容器view中,然后对容器view添加动画效,动画结束后把跳转之前控制器的view从window中移除.在window中之前<br>的view完全被弹出的view替代最终看到如下图的视图结构</p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/modal%20%E8%A7%86%E5%9B%BE%E7%BB%93%E6%9E%84.png" alt="modal视图结构"></p>
<p>如你在上图中看到的,黑色的是window,蓝色的为弹出的View,而中间的就是容器View.容器view的类型是UITransitionView<br>dismiss的过程是present的逆过程,除了从底部弹出的动画UIKit还提供了多种动画效果可以通过设置弹出控制器modalTransitionStyle属性.<br>这里有个需要注意点,当设置modalPresentationStyle为Custom时原控制器的view并不会从window中移除.同时如果设置了transitioningDelegate<br>那么modalTransitionStyle设置的动画效果将全部失效,此时动画全权交给代理来完成. UIViewControllerTransitioningDelegate协议包含五个函数<br>这里只需要关注Getting the Transition Animator Objects的两个函数,这两个函数都需要返回一个实现UIViewControllerAnimatedTransitioning协议的实例对象,<br>具体的动画逻辑将在这个实例对象的方法中完成.</p>
<h1 id="添加点击跳转到大图浏览动画"><a href="#添加点击跳转到大图浏览动画" class="headerlink" title="添加点击跳转到大图浏览动画"></a>添加点击跳转到大图浏览动画</h1><p>按上一节的分析需要在点击缩略图时把大图控制器的modalPresentationStyle设为.Custom,并且过渡动画(transitioningDelegate)设置代理对象,具体代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override func collectionView(collectionView: UICollectionView, didSelectItemAtIndexPath indexPath: NSIndexPath) &#123;</span><br><span class="line">    let photoVC = PhotoBrowseCollectionVC()</span><br><span class="line">    photoVC.indexPath = indexPath</span><br><span class="line">    photoVC.items = shopitems</span><br><span class="line">    photoVC.transitioningDelegate = modalDelegate</span><br><span class="line">    photoVC.modalPresentationStyle = .Custom</span><br><span class="line">    presentViewController(photoVC, animated: true, completion: nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>modalDelegate是ModalAnimationDelegate的实例对象,其实现了UIViewControllerTransitioningDelegate协议方法,animationControllerForPresentedController<br>返回本身的实例对象,所以ModalAnimationDelegate也要实现UIViewControllerAnimatedTransitioning协议方法.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</span><br><span class="line">   return self</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在具体的动画逻辑就转到了UIViewControllerAnimatedTransitioning协议的animateTransition方法中.要实现从选中的图片慢慢放大的效果分成如下几步</p>
<ul>
<li>取出容器view,也就是上一节提到的UITransitionView实例对象</li>
<li>取出要弹出的目标view,在这里就是展示大图的colletionview,并添加到容器view</li>
<li>新建UIImageView对象,得到选中的UIImage对像,及其在window上的frame</li>
<li>把新建的UIImageView对象添加到容器view</li>
<li>设置新建UIImageView的放大动画,动画结果束后从容器view中移除</li>
<li>通知系统动画完成(主动调用completeTransition)</li>
</ul>
<p>把动画的实现分解开来是不是清晰很多了,具体实现还是得参看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">func presentViewAnimation(transitionContext: UIViewControllerContextTransitioning) &#123;</span><br><span class="line"></span><br><span class="line">    // 目标view</span><br><span class="line">    let destinationView = transitionContext.viewForKey(UITransitionContextToViewKey)</span><br><span class="line">    // 容器view</span><br><span class="line">    let containerView = transitionContext.containerView()</span><br><span class="line">    guard let _ = destinationView else &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // 目标view添加到容器view上</span><br><span class="line">    containerView?.addSubview(destinationView!)</span><br><span class="line">    // 获取目标控制器</span><br><span class="line">    let destinationController = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey) as? PhotoBrowseCollectionVC</span><br><span class="line">    let indexPath = destinationController?.indexPath</span><br><span class="line">    // 跳转前的控制器</span><br><span class="line">    let collectionViewController = ((transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)) as! UINavigationController).topViewController as! UICollectionViewController</span><br><span class="line">    let currentCollectionView = collectionViewController.collectionView</span><br><span class="line">    // 当前选中的cell</span><br><span class="line">    let selectctedCell = currentCollectionView?.cellForItemAtIndexPath(indexPath!) as? CollectionViewCell</span><br><span class="line">    // 新建一个imageview添加到目标view之上,做为动画view</span><br><span class="line">    let annimateViwe = UIImageView()</span><br><span class="line">    annimateViwe.image = selectctedCell?.imageView.image</span><br><span class="line">    annimateViwe.contentMode = .ScaleAspectFill</span><br><span class="line">    annimateViwe.clipsToBounds = true</span><br><span class="line">    // 被选中的cell到目标view上的座标转换</span><br><span class="line">    let originFrame = currentCollectionView!.convertRect(selectctedCell!.frame, toView: UIApplication.sharedApplication().keyWindow)</span><br><span class="line">    annimateViwe.frame = originFrame</span><br><span class="line">    containerView?.addSubview(annimateViwe)</span><br><span class="line">    let endFrame = coverImageFrameToFullScreenFrame(selectctedCell?.imageView.image)</span><br><span class="line">    destinationView?.alpha = 0</span><br><span class="line">    // 过渡动画执行</span><br><span class="line">    UIView.animateWithDuration(1, animations: &#123;</span><br><span class="line">        annimateViwe.frame = endFrame</span><br><span class="line">    &#125;) &#123; (finished) in</span><br><span class="line">        transitionContext.completeTransition(true)</span><br><span class="line">        UIView.animateWithDuration(0.5, animations: &#123;</span><br><span class="line">            destinationView?.alpha = 1</span><br><span class="line">        &#125;) &#123; (_) in</span><br><span class="line">            annimateViwe.removeFromSuperview()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的关键是怎样通过transitionContext拿到两个控制器.通过UITransitionContextFromViewControllerKey拿到的是转跳前控制器的父控制器,由于Demo中缩略图控制器内嵌了导航控制器所以在Demo中拿到就是导航控制器,经过一系列的转换才能拿到选中的图片.拿到选中的图片后需要计算动画开始和结束的frame,开始的frame是将选中的cell座标直接转换到window上<br>结束的frame是UIImageView放大到屏宽并居中的frame,具体计算方法参看Demo的coverImageFrameToFullScreenFrame全局函数.<br>另外UIViewControllerAnimatedTransitioning协议另一个必须要实现的函数是transitionDuration,这个函数决定了动画执行的时长.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval &#123;</span><br><span class="line">        return 1.0</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="添加轻击回到小图浏览动画"><a href="#添加轻击回到小图浏览动画" class="headerlink" title="添加轻击回到小图浏览动画"></a>添加轻击回到小图浏览动画</h1><p>轻击dismiss的过程与上一节弹出正好相反,但仍有所区别.过程如下:</p>
<ul>
<li>取出弹出的大图colletionview,得到当前轻击的图片</li>
<li>新建UIImageView作为动画view,并把上一步得到的image给新建UIImageView</li>
<li>得到选中图片在window上的frame,并设置为新建UIImageView动画的开始frame</li>
<li>得到当前轻击的大图对应的缩略图的frame,并将其做为动画结束frame</li>
<li>执行动画,动画结束后移除UIImageView</li>
<li>通知系统动画完成(主动调用completeTransition)</li>
</ul>
<p>与present过程不同的是UITransitionContextFromViewControllerKey和UITransitionContextToViewControllerKey两个key正好相反,present过程的FromVC是缩略图的父控制器,toTV是大图浏览控制器.而dismiss与present是相反的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func dismissViewAnimation(transitionContext: UIViewControllerContextTransitioning) &#123;</span><br><span class="line">    let transitionView = transitionContext.viewForKey(UITransitionContextFromViewKey)</span><br><span class="line">    let contentView = transitionContext.containerView()</span><br><span class="line">    // 取出modal出的来控制器</span><br><span class="line">    let destinationController = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey) as! UICollectionViewController</span><br><span class="line">    // 取出当前显示的collectionview</span><br><span class="line">    let presentView = destinationController.collectionView</span><br><span class="line">    // 取出控制器当前显示的cell</span><br><span class="line">    let dismissCell = presentView?.visibleCells().first as? CollectionViewCell</span><br><span class="line">    // 新建过渡动画imageview</span><br><span class="line">    let animateImageView = UIImageView()</span><br><span class="line">    animateImageView.contentMode = .ScaleAspectFill</span><br><span class="line">    animateImageView.clipsToBounds = true</span><br><span class="line">    // 获取当前显示的cell的image</span><br><span class="line">    animateImageView.image = dismissCell?.imageView.image</span><br><span class="line">    // 获取当前显示cell在window中的frame</span><br><span class="line">    animateImageView.frame = (dismissCell?.imageView.frame)!</span><br><span class="line">    contentView?.addSubview(animateImageView)</span><br><span class="line">    // 缩略图对应的indexPath</span><br><span class="line">    let indexPath = presentView?.indexPathForCell(dismissCell!)</span><br><span class="line">    // 取出要返回的控制器view</span><br><span class="line">    let originView = ((transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey) as! UINavigationController).topViewController as! UICollectionViewController).collectionView</span><br><span class="line">    var originCell = originView!.cellForItemAtIndexPath(indexPath!)</span><br><span class="line">    // 得到返回后对应cell在window上的frame</span><br><span class="line">    let originFrame = originView?.convertRect(originCell!.frame, toView: UIApplication.sharedApplication().keyWindow)</span><br><span class="line">    UIView.animateWithDuration(1, animations: &#123;</span><br><span class="line">        animateImageView.frame = originFrame!</span><br><span class="line">        transitionView?.alpha = 0</span><br><span class="line">    &#125;) &#123; (_) in</span><br><span class="line">        animateImageView.removeFromSuperview()</span><br><span class="line">        transitionContext.completeTransition(true)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>present和dismiss时都会调用到UIViewControllerAnimatedTransitioning协议的animateTransition方法,为区分dismiss和present的动画,定义一个属性isPresentAnimationing表明当前要执行的是dismiss还是present,而当前执行的动画是由UIViewControllerTransitioningDelegate协议的animationControllerForPresentedController和animationControllerForDismissedController两个函数决定的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</span><br><span class="line">   isPresentAnimationing = true</span><br><span class="line">   return self</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func animationControllerForDismissedController(dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</span><br><span class="line">   isPresentAnimationing = false</span><br><span class="line">   return self</span><br><span class="line">&#125;</span><br><span class="line">func animateTransition(transitionContext: UIViewControllerContextTransitioning) &#123;</span><br><span class="line">    isPresentAnimationing ? presentViewAnimation(transitionContext) : dismissViewAnimation(transitionContext)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="要注意的问题"><a href="#要注意的问题" class="headerlink" title="要注意的问题"></a>要注意的问题</h1><p>其实上在dismiss动画逻辑留下了一个坑,dismiss时需要获取对应缩略图的cell进而得到动画结束的frame,而获取这个cell用了cellForItemAtIndexPath方法</p>
<figure class="highlight plain"><figcaption><span>dismissViewAnimation 函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">let originView = ((transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey) as! UINavigationController).topViewController as! UICollectionViewController).collectionView</span><br><span class="line">var originCell = originView!.cellForItemAtIndexPath(indexPath!)</span><br><span class="line">// 得到返回后对应cell在window上的frame</span><br><span class="line">let originFrame = originView?.convertRect(originCell!.frame, toView: UIApplication.sharedApplication().keyWindow)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>而cellForItemAtIndexPath只能返回正在显示的cell,没有被显示的cell将返回nil.所以当大图对应的缩略图没有被显示在colletionview中时强制解包就会抛出异常.也就是说当选择查看当前显示缩略图的最后一张对应的大图时就会闪退.解决的办是若用cellForItemAtIndexPath取不到cell则将应的cell滚动到可视范围内,由于cellForItemAtIndexPath需要下一个显示周期才能显示所以要主动调用layoutIfNeeded,实现如下</p>
<figure class="highlight plain"><figcaption><span>dismissViewAnimation 函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var originCell = originView!.cellForItemAtIndexPath(indexPath!)</span><br><span class="line">if originCell == nil &#123;</span><br><span class="line">    originView?.scrollToItemAtIndexPath(indexPath!, atScrollPosition: .CenteredVertically, animated: false)</span><br><span class="line">    originView?.layoutIfNeeded()</span><br><span class="line">&#125;</span><br><span class="line">originCell = originView!.cellForItemAtIndexPath(indexPath!)</span><br><span class="line">let originFrame = originView?.convertRect(originCell!.frame, toView: UIApplication.sharedApplication().keyWindow)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面啰啰嗦嗦写了很多我认为是废话的话,其实实现类似微信微博的图片浏览动画的核心在于dismissViewAnimation和presentViewAnimation函数.本文只是通过一个简单的demo实现了相同的效果,为大家在自己项目中实现类似效果提供一个可参考的思路.当然本人水平有限,或许你知道更简单有效的方法希望也告知我.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[你觉得简单的区分网络环境的图片加载]]></title>
      <url>http://lemtter.com/2015/09/05/%E4%BD%A0%E8%A7%89%E5%BE%97%E7%AE%80%E5%8D%95%E7%9A%84%E5%8C%BA%E5%88%86%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83%E7%9A%84%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD/</url>
      <content type="html"><![CDATA[<p>对于一个图片较多的应用来说，产品可能会提出根据网络环境下载不同大小图片的需求，比如在WiFI环境时下载高清图，在WLAN时下载一般图片。这对这个需求一般程序员都会觉得这不是很简单的事件吗？直接获取当前网络环境然后下载并设置图片，于是三下五除二的写出了以下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- setItem:(CustomItem *)item</span><br><span class="line">&#123;</span><br><span class="line">    _item = item;</span><br><span class="line">    UIImage *placeholder = [UIImage imageNamed:@&quot;placeholderImage&quot;];</span><br><span class="line">    AFNetworkReachabilityManager *mgr = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line">    if (mgr.isReachableViaWiFi) &#123; // 在使用Wifi, 下载原图</span><br><span class="line">        [self.imageView sd_setImageWithURL:[NSURL URLWithString:item.originalImage] placeholderImage:placeholder];</span><br><span class="line">    &#125; else &#123; // 其他，下载小图</span><br><span class="line">        [self.imageView sd_setImageWithURL:[NSURL URLWithString:item.thumbnailImage] placeholderImage:placeholder];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>上面代码是一般情况下对自定义视图设置模型数据，然后根据模型数据更新UI，这个没什么好说的。那上面的方法有什么问题呢？问题大了去了，上面的代码虽然也能给用户节省一点点流量也不会造成应用崩溃或降低流畅度，在这种情况下不明真相的测试小妹和产品都会觉得程序小哥很给力，做事真利索。我们都知道SDWebImage会缓存已经下载过的图片，设想一下如果手机沙盒或内存中缓存了高清图，而这时又是在WLAN网络下，根据以上代码就会直接去下载一般图片。这就很尴尬了，手机里面明明有高清图非得给我去下载不清晰的图片。又比如，用户当前没有网络但是呢又缓存高清图，然后又根据以上代码程序小哥给设置了占位图，我明明有高清图啊大哥，你为毛要设置占位图？发现问题的聪明程序小哥又会写出以下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- setItem:(CustomItem *)item</span><br><span class="line">&#123;</span><br><span class="line">    _item = item;</span><br><span class="line">     // 占位图片</span><br><span class="line">    UIImage *placeholder = [UIImage imageNamed:@&quot;placeholderImage&quot;];</span><br><span class="line">    // 从内存\沙盒缓存中获得原图，</span><br><span class="line">    UIImage *originalImage = [[SDImageCache sharedImageCache] imageFromDiskCacheForKey:item.originalImage];</span><br><span class="line">    if (originalImage) &#123; // 如果内存\沙盒缓存有原图，那么就直接显示原图（不管现在是什么网络状态）</span><br><span class="line">        self.imageView.image = originalImage;</span><br><span class="line">    &#125; else &#123; // 内存\沙盒缓存没有原图</span><br><span class="line">        AFNetworkReachabilityManager *mgr = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line">        if (mgr.isReachableViaWiFi) &#123; // 在使用Wifi, 下载原图</span><br><span class="line">            [self.imageView sd_setImageWithURL:[NSURL URLWithString:item.originalImage] placeholderImage:placeholder];</span><br><span class="line">        &#125; else if (mgr.isReachableViaWWAN) &#123; // 在使用手机自带网络</span><br><span class="line">            //     用户的配置项假设利用NSUserDefaults存储到了沙盒中</span><br><span class="line">            //    [[NSUserDefaults standardUserDefaults] setBool:NO forKey:@&quot;alwaysDownloadOriginalImage&quot;];</span><br><span class="line">            //    [[NSUserDefaults standardUserDefaults] synchronize];</span><br><span class="line">            #warning 从沙盒中读取用户的配置项：在3G\4G环境是否仍然下载原图</span><br><span class="line">            BOOL alwaysDownloadOriginalImage = [[NSUserDefaults standardUserDefaults] boolForKey:@&quot;alwaysDownloadOriginalImage&quot;];</span><br><span class="line">            if (alwaysDownloadOriginalImage) &#123; // 下载原图</span><br><span class="line">                [self.imageView sd_setImageWithURL:[NSURL URLWithString:item.originalImage] placeholderImage:placeholder];</span><br><span class="line">            &#125; else &#123; // 下载小图</span><br><span class="line">                [self.imageView sd_setImageWithURL:[NSURL URLWithString:item.thumbnailImage] placeholderImage:placeholder];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123; // 没有网络</span><br><span class="line">            UIImage *thumbnailImage = [[SDImageCache sharedImageCache] imageFromDiskCacheForKey:item.thumbnailImage];</span><br><span class="line">            if (thumbnailImage) &#123; // 内存\沙盒缓存中有小图</span><br><span class="line">                self.imageView.image = thumbnailImage;</span><br><span class="line">            &#125; else &#123; // 处理离线状态，而且有没有缓存时的情况</span><br><span class="line">                self.imageView.image = placeholder;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这仍然会很尴尬，如果以上代码是设置UITableView里cell的图片，网络环境差的时候就会出现已经显示的图片突然被设置成另外一张图造成数据错乱。为什么会数据错乱呢？调用sd_setImageWithURL方法会关联对应的UIImageView,当cell滚出屏幕然扔到缓存里而图片还在后台继续下载并且这种关联的关系仍然会存在.随着用户继续滑动tableview，缓存里的cell被重用于是上面的方法再次被调用设置新的图片。这个时候就会有两个下载对象关联同一个UIImageView对象。如果后添加的下载任务先完成就会出现已经显示的图片突然被设置成了另一张，由此造成数据错乱。</p>
<p>如果你研究过SDWebImage的源码，会发现在sd_setImageWithURL: placeholderImage:方法中会这么一句[self sd_cancelCurrentImageLoad],对，在这个方法中会取消之前下载任务，所以我们最终的代码是以下的样子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (void)setImageWihtOriginImageURL:(NSString *)originURL thumbnailImageULR:(NSString *)thumbnialImageURL placeholderImage:(UIImage *)placeholderImage completed:(SDWebImageCompletionBlock)completedBlock &#123;</span><br><span class="line"></span><br><span class="line">    // 查看内存磁盘是否有原图</span><br><span class="line">    UIImage *image = [[SDImageCache sharedImageCache] imageFromDiskCacheForKey:originURL];</span><br><span class="line">    if (image) &#123;</span><br><span class="line">        //取消原来的下载队列(如果有),并加载图片</span><br><span class="line">        [self sd_setImageWithURL:[NSURL URLWithString:originURL] completed:completedBlock];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        AFNetworkReachabilityManager *manager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line">        if (manager.reachableViaWiFi) &#123; // 如果有wifi则下载原图</span><br><span class="line">            [self sd_setImageWithURL:[NSURL URLWithString:originURL] placeholderImage:placeholderImage completed:completedBlock];</span><br><span class="line">        &#125; else if (manager.reachableViaWWAN) &#123;</span><br><span class="line">            //根据用户设置是否在wan下下载原图</span><br><span class="line">            BOOL downloadOriginImage = [[NSUserDefaults standardUserDefaults] boolForKey:@&quot;alwaysDownloadOriginImage&quot;]; // 用wan情况下根据用户选择下载</span><br><span class="line">            if (downloadOriginImage) &#123;</span><br><span class="line">                [self sd_setImageWithURL:[NSURL URLWithString:originURL] placeholderImage:placeholderImage completed:completedBlock];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                [self sd_setImageWithURL:[NSURL URLWithString:thumbnialImageURL] placeholderImage:placeholderImage completed:nil];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123; // 没有可用网络</span><br><span class="line">            UIImage *image = [[SDImageCache sharedImageCache] imageFromDiskCacheForKey:thumbnialImageURL];</span><br><span class="line">            if (image) &#123; //如果有缩略图 取消原队列的下载并加载本地图片</span><br><span class="line">                [self sd_setImageWithURL:[NSURL URLWithString:thumbnialImageURL] completed:completedBlock];</span><br><span class="line">            &#125; else &#123; // 没有网络也没有本地图片则设置占位图片</span><br><span class="line">                [self sd_setImageWithURL:nil placeholderImage:placeholderImage completed:completedBlock];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Xcode调试巧]]></title>
      <url>http://lemtter.com/2015/09/05/Xcode%E8%B0%83%E8%AF%95%E5%B7%A7/</url>
      <content type="html"><![CDATA[<h2 id="Enable-NSZombie-Objects-开启僵尸对象"><a href="#Enable-NSZombie-Objects-开启僵尸对象" class="headerlink" title="Enable NSZombie Objects (开启僵尸对象)"></a>Enable NSZombie Objects (开启僵尸对象)</h2><p>首先打开 <strong>Edit Scheme</strong><br><img src="http://o6jvfp7kw.bkt.clouddn.com/edit_scheme.png" alt="Edit Scheme"></p>
<p>再选中 <strong>Enable Zombie Objects</strong></p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/edit_scheme_detail.png" alt="Edit Scheme Detail"></p>
<p>开启僵尸对象会容易观察到被重复释放的对象,即使在 ARC 项目中也会经常发生对象被重复释放引起的 Crashs,编绎器会让重复释放的象的调试信息更加直观</p>
<a id="more"></a>
<h2 id="给所有异常添加-Global-BreakPoint-全局断点"><a href="#给所有异常添加-Global-BreakPoint-全局断点" class="headerlink" title="给所有异常添加(Global BreakPoint)全局断点"></a>给所有异常添加(Global BreakPoint)全局断点</h2><p>一般情况在应用崩溃时Xcode喜欢直接跳到main 函数中去,以至于应用到底在哪个地方崩了不是很直观.global breakpoint可以在应用调试时在抛出异常的地方直接添加断点,这样就可以捕获异常的具体的异常信息. <strong>添加方法如下:</strong></p>
<p><a href="http://o6jvfp7kw.bkt.clouddn.com/exceptions.png" target="_blank" rel="external">exception</a></p>
<h2 id="Static-Analyzer-静态分析"><a href="#Static-Analyzer-静态分析" class="headerlink" title="Static Analyzer 静态分析"></a>Static Analyzer 静态分析</h2><p>Static Analyzer是一个非常好的工具去发现编译器警告不会提示的问题和一些个人的内错泄露和死存储（不会用到的赋了值的变量）错误。这个方法可能大大的提高内存使用和性能，以及提升应用的整体稳定性和代码质量。</p>
<p>怎么打开Static Analyzer？打开Xcide的<strong>Product</strong>菜单，选择<strong>Analyzer</strong>选项,Static Analyzer会捕获任何应用内的可能的问题然后以蓝色的警告展示出来.</p>
<h2 id="Condational-Breakpoints（条件断点）"><a href="#Condational-Breakpoints（条件断点）" class="headerlink" title="Condational Breakpoints（条件断点）"></a>Condational Breakpoints（条件断点）</h2><p>最后一个调试技巧条件断点，这只是普通的断点，当变量满足一定条件时程序停止。这个调试技巧在当你想要捕获一个循环中的变量的特定值或者一些不常发生的情况时是非常有用的，而不用你每次迭代都停止来查看。</p>
<p>怎样开启条件变量？只不过是添加一个普通断点，然后右键点击断点选择<strong>Edit Breakpoint</strong>，这时就打开了一个断点编辑器，你可以在这里设置断点条件（以及一些其他的断点设置），然后选择<strong>Done</strong>，这个调试技巧非常简单吧。</p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/condition_breakpoint.png" alt="condition_breakpoint"></p>
<h2 id="unrecognized-selector-send-to-instancd-快速定位"><a href="#unrecognized-selector-send-to-instancd-快速定位" class="headerlink" title="unrecognized selector send to instancd 快速定位"></a>unrecognized selector send to instancd 快速定位</h2><p>在Debug菜单中 <strong>Breakpoints-&gt;Create Symbolic Breakpoint</strong></p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/Symbolic_breakpoint.png" alt="SymbolicBreakPoint"> 在<strong>Symbolic</strong>中填写如下方法签名   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-[NSObject(NSObject)doesNotRecognizeSelector:]</span><br></pre></td></tr></table></figure>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/symbolic_breakpoint_edit.png" alt="SymbolicBreakPointEdit"></p>
<p>设置完成后再遇到类似的错误就会定位到具体的代码。</p>
<h2 id="NSLog-不打印设置"><a href="#NSLog-不打印设置" class="headerlink" title="NSLog 不打印设置"></a>NSLog 不打印设置</h2><p>在xcode中开发时经常会添加一些打印信息,这些打印信息在模拟器中通常不会有什么影响,因为模拟器用的是 mac的硬件资源.当跑在真机中时过多的打印信息就会影响到性能了.除此之外打印信息也会暴露出一些应用的敏感信息.因此区分调试与正式应用的打印设置就非常有必要了.</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>在-Prefix.pch（pch全称是”precompiled header”，也就是预编译头文件，该文件里存放的工程中一些不常被修改的代码，比如常用的框架头文件，这样做的目的提高编译器编译速度。我们知道当我们修改一个工程中某个文件代码时候，编译器并不是重新编译所有所有文件，而是编译改动过文件的，假如pch中某个文件修改了，那么pch整个文件里包含的的其他文件也会重新编译一次，这样就会消耗大量时间，所以它里面添加的文件最好是是很少变动或不变动的头文件或者是预编译的代码片段；）文件中添加    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#ifdef DEBUG</span><br><span class="line">#define NSLog(...) NSLog(__VA_ARGS__)</span><br><span class="line">#define debugMethod() NSLog(@&quot;%s&quot;, __func__)</span><br><span class="line">#else</span><br><span class="line">#define NSLog(...)</span><br><span class="line">#define debugMethod()</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>上段代码的意思就是用宏指令做一个判断，如果DEBUG为真，则编译#ifdef到#endif宏定义，否则编译器就不编译；在 xcode6以后新建工程就不会自动生prefix.pch 文件了,所以我们可以新建一个pch文件来添加以上代码.另外还要将新创建的PCH file的路径添加到building setting中的precompile header(Apple LLVM 7.0 - Language)选项中去，注意debug和release两栏都要添加：</p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/perfixheader.png" alt="perfixheader"></p>
<h3 id="如何设置"><a href="#如何设置" class="headerlink" title="如何设置"></a>如何设置</h3><p>在 <strong>“Target &gt; Build Settings &gt; Preprocessor Macros &gt; Debug”</strong> 里有一个 <strong>“DEBUG=1”</strong>。<br> <img src="http://o6jvfp7kw.bkt.clouddn.com/nslog_macro.png" alt="nslog_macro"></p>
<p>设置为Debug模式下，<strong>Product–&gt;Scheme–&gt;SchemeEdit Scheme</strong>设置<strong>Build</strong>  <strong>Configuration</strong> 成<strong>Debug</strong> 时，就可以打印nslog了。设置Release，发布app版本的时候就不会打印了，提高了性能</p>
<p><img src="http://o6jvfp7kw.bkt.clouddn.com/nslog.png" alt="nslog"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS数据存储方式总结]]></title>
      <url>http://lemtter.com/2015/06/05/iOS%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<blockquote>
<p>iOS应用中常用的数据存储方式有plist Preference(偏好设置),NSKeyedArchiver归档,SQLite3和 Core Data.接下来将介绍这几种数据存储方式的使用</p>
</blockquote>
<p><em>既然是要存储数据,就得有数据存储的路径.在 iOS中获取文路径有固定的两种方法,由于 iOS沙盒机制的存在每个App只能访问到自己所属的几个文件路径.所以在正式介绍存储数据方式之前先了解沙盒路径,以及如何获取沙盒的路径</em></p>
<hr>
<a id="more"></a>
<h2 id="iOS-应用沙盒"><a href="#iOS-应用沙盒" class="headerlink" title="iOS 应用沙盒"></a>iOS 应用沙盒</h2><ul>
<li>每个iOS应用都有自己的应用沙盒(应用沙盒就是文件系统目录)，与其他文件系统隔离。应用必须待在自己的沙盒里，其他应用不能访问该沙盒</li>
<li><p>App沙盒的文件系统目录 <img src="http://o6jvfp7kw.bkt.clouddn.com/%E6%B2%99%E7%9B%92%E7%9B%AE%E5%BD%95.png" alt="沙盒目录.png"></p>
<p>模拟器沙盒目录在/Users/用户名/Library/Developer/CoreSimulator/Devices//data/Containers/Data/Application//Documents</p>
<p>需要意的是 App的 Bundle 并不在这一目录下,而是在/Users/用户名/Library/Developer/CoreSimulator/Devices//data/Bundle/Application进行统一的管理</p>
</li>
</ul>
<h3 id="App-应用沙盒结构分析"><a href="#App-应用沙盒结构分析" class="headerlink" title="App 应用沙盒结构分析"></a>App 应用沙盒结构分析</h3><ul>
<li>Documents：保存应用运行时生成的需要持久化的数据，iTunes同步设备时会备份该目录。例如，游戏应用可将游戏存档保存在该目录</li>
<li>tmp：保存应用运行时所需的临时数据，使用完毕后再将相应的文件从该目录删除。应用没有运行时，系统也可能会清除该目录下的文件。iTunes同步设备时不会备份该目录</li>
<li>Library/Caches：保存应用运行时生成的需要持久化的数据，iTunes同步设备时不会备份该目录。一般存储体积大、不需要备份的非重要数据</li>
<li>Library/Preference：保存应用的所有偏好设置，iOS的Settings(设置)应用会在该目录中查找应用的设置信息。iTunes同步设备时会备份该目录</li>
</ul>
<h3 id="获取沙盒目录的两种方式"><a href="#获取沙盒目录的两种方式" class="headerlink" title="获取沙盒目录的两种方式"></a>获取沙盒目录的两种方式</h3><ul>
<li>利用 NSHomeDirectory()函数,配合 stringByAppendingPathComponent:拼接成完整的根目录.</li>
</ul>
<p><em>Demo Code</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *home = NSHomeDirectory();</span><br><span class="line">NSString *documents = [home stringByAppendingPathComponent:@&quot;Documents&quot;];</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> 不建议采用这种方式来获取沙盒根目录,因为我们手敲的@”Documents”可能在未来某一版本的操作系统会被更改成其它的名字</p>
<ul>
<li>利用 NSSearchPathForDirectoriesInDomains函数</li>
</ul>
<p><em>Demo code</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//NSUserDominMask 代表从用户文件目录下找</span><br><span class="line">//YES 代表展开路径中的波浪字符&quot;~&quot;</span><br><span class="line">NSSArray *array = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDominMask, NO);</span><br><span class="line">//在 iOS中,只有一个目录跟传入的参数匹配,所以这个集合只有一个元素</span><br><span class="line">NSString *document = [array objectAtIndex:0];</span><br></pre></td></tr></table></figure>
<h2 id="属性列表存储方式"><a href="#属性列表存储方式" class="headerlink" title="属性列表存储方式"></a>属性列表存储方式</h2><p><em>属性列表是一种XML格式的文件，拓展名为plist,如果对象是NSString、NSDictionary、NSArray、NSData、NSNumber等类型，就可以使用writeToFile:atomically:方法直接将对象写到属性列表文件中,但是自定义的类并不写直接写入 plist文件</em></p>
<ul>
<li>将对象写入 plist</li>
</ul>
<p><em>Demo Code: 将一个 NSDictionary 对象中封装的数据保存到 plist 属性列表</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 将数据封装到字典中</span><br><span class="line">NSMutableDictionary *dict = [NSMutableDictionary dictionary];</span><br><span class="line">[dict setObject:@&quot;Jack&quot; forKey:@&quot;name&quot;];</span><br><span class="line">[dict setObject:@&quot;15013141314&quot; forKey:@&quot;phone&quot;];</span><br><span class="line">// 将数据写入到 plist文件保存,path为上一节所获取到的沙盒路径</span><br><span class="line">[dict writeToFile:path atomically:YES];</span><br></pre></td></tr></table></figure>
<ul>
<li>将数据从 plist恢复</li>
</ul>
<p><em>Demo Code</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 读取Documents/stu.plist的内容，实例化NSDictionary</span><br><span class="line">NSDictionary *dict = [NSDictionary dictionaryWithContentsOfFile:path];</span><br><span class="line">NSLog(@&quot;name:%@&quot;, [dict objectForKey:@&quot;name&quot;]);</span><br><span class="line">NSLog(@&quot;phone:%@&quot;, [dict objectForKey:@&quot;phone&quot;]);</span><br></pre></td></tr></table></figure>
<h2 id="偏好-也叫默认-设置存储方式"><a href="#偏好-也叫默认-设置存储方式" class="headerlink" title="偏好(也叫默认)设置存储方式"></a>偏好(也叫默认)设置存储方式</h2><blockquote>
<p>很多iOS应用都支持偏好设置，比如保存用户名、密码、字体大小等设置，iOS提供了一套标准的解决方案来为应用加入偏好设置功能.每个应用都有个NSUserDefaults实例，通过它来存取偏好设置.实际上这种方式也是将数据保存为 plist 文件,只是NSUserDefaults类实现了一套自己的读取与保存 plist文件的方法.</p>
</blockquote>
<ul>
<li>NSUserDefaults存储数据的方式</li>
</ul>
<p>话不多说,直接上代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">[defaults setObject:@&quot;itcast&quot; forKey:@&quot;username&quot;];</span><br><span class="line">[defaults setFloat:18.0f forKey:@&quot;text_size&quot;];</span><br><span class="line">[defaults setBool:YES forKey:@&quot;auto_login&quot;];</span><br><span class="line">//同步,立即写入文件</span><br><span class="line">[defautls synchronize]</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> UserDefaults设置数据时,不是立即写入而是根据时间戳定时地把缓存中的数据写入本地磁盘。所以调用了set方法之后数据有可能还没有写入磁盘应用程序就终止了.出现以上问题，可以通过调用synchornize方法强制写入</p>
<ul>
<li>UserDefaults读取数据</li>
</ul>
<p><em>Demo Code</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">NSString *username = [defaults stringForKey:@&quot;username&quot;];</span><br><span class="line">float textSize = [defaults floatForKey:@&quot;text_size&quot;];</span><br><span class="line">BOOL autoLogin = [defaults boolForKey:@&quot;auto_login&quot;];</span><br></pre></td></tr></table></figure>
<h2 id="NSKeyedArchiver方式存储数据"><a href="#NSKeyedArchiver方式存储数据" class="headerlink" title="NSKeyedArchiver方式存储数据"></a>NSKeyedArchiver方式存储数据</h2><p>如果对象是NSString、NSDictionary、NSArray、NSData、NSNumber等类型，可以直接用NSKeyedArchiver进行归档和恢复,但不是所有的对象都可以直接用这种方法进行归档，只有遵守了NSCoding协议的对象才可以.</p>
<h3 id="NSCoding协议"><a href="#NSCoding协议" class="headerlink" title="NSCoding协议"></a>NSCoding协议</h3><p>NSCoding只有两个协议方法 encodeWithCoder: ,initWithCoder:</p>
<ul>
<li>encodeWithCoder: 每次归档(archiver)对象时都会调用这个方法进行压缩归档.一般在这个方法里面指定如何归档对象中的每个实例变量，可以使用encodeObject:forKey:方法归档实例变量</li>
<li>initWithCoder: 每次从文件中恢复对象时,都调用这个方法.一般在这个方法里面指定如何解码文件中的数据为对象的实例变量,解码实例变量可以用decodeObject:forKey方法</li>
</ul>
<p><em>Demo Code 归档一个包含自定义Person对象的数组</em></p>
<p><em>Person.h</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject&lt;NSCoding&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic, assign) int age;</span><br><span class="line">@property (nonatomic, assign) float height;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">-(void)encodeWithCoder:(NSCoder *)encoder &#123;</span><br><span class="line">    [encoder encodeObject:self.name forKey:@&quot;name&quot;];</span><br><span class="line">    [encoder encodeInt:self.age forKey:@&quot;age&quot;];</span><br><span class="line">    [encoder encodeFloat:self.height forKey:@&quot;height&quot;];</span><br><span class="line">&#125;</span><br><span class="line">- (id)initWithCoder:(NSCoder *)decoder &#123;</span><br><span class="line">    self.name = [decoder decodeObjectForKey:@&quot;name&quot;];</span><br><span class="line">    self.age = [decoder decodeIntForKey:@&quot;age&quot;];</span><br><span class="line">    self.height = [decoder decodeFloatForKey:@&quot;height&quot;];</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><em>归档(编码)</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">person.name = @&quot;MJ&quot;;</span><br><span class="line">person.age = 27;</span><br><span class="line">person.height = 1.83f;</span><br><span class="line">[NSKeyedArchiver archiveRootObject:person toFile:path];</span><br></pre></td></tr></table></figure>
<p><em>恢复(解码)</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [NSKeyedUnarchiver unarchiveObjectWithFile:path];</span><br></pre></td></tr></table></figure>
<p><strong>如果父类也遵守了NSCoding协议需要注意注的点</strong></p>
<ul>
<li>应该在encodeWithCoder:方法中加上一句[super encodeWithCode:encode];确保继承的实例变量也能被编码</li>
<li>确保继承的实例变量也能被解码，即也能被归档应该在initWithCoder:方法中加上一句self = [super initWithCoder:decoder];</li>
</ul>
<h3 id="归档的另类使用方式"><a href="#归档的另类使用方式" class="headerlink" title="归档的另类使用方式"></a>归档的另类使用方式</h3><p><em>利用归档实现深复制</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 临时存储person1的数据</span><br><span class="line">NSData *data = [NSKeyedArchiver archivedDataWithRootObject:person1];</span><br><span class="line">// 解析data，生成一个新的Person对象</span><br><span class="line">Student *person2 = [NSKeyedUnarchiver unarchiveObjectWithData:data];</span><br></pre></td></tr></table></figure>
<h2 id="NSData方式保存数据"><a href="#NSData方式保存数据" class="headerlink" title="NSData方式保存数据"></a>NSData方式保存数据</h2><p>NSData的方式保存数据其实是作为NSKeyedArchiver的补充,NSKeyedArchiver每次只能用archiveRootObject:toFile:方法保存一个数据对象.如果需要同时保存多个数据对象则需要借助NSData,NSData可以为一些数据提供临时存储空间，以便随后写入文件，或者存放从磁盘读取的文件内容.可以使用[NSMutableData data]创建可变数据空间. 借助NSData实现多个对象的归档的过程可以用如下图示表示: <img src="http://upload-images.jianshu.io/upload_images/659811-ae133f6598ecb770.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="data"></p>
<p><em>Demo Code: 归档多个对象</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 新建一块可变数据区</span><br><span class="line">NSMutableData *data = [NSMutableData data];</span><br><span class="line">// 将数据区连接到一个NSKeyedArchiver对象</span><br><span class="line">NSKeyedArchiver *archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];</span><br><span class="line">// 开始存档对象，存档的数据都会存储到NSMutableData中</span><br><span class="line">[archiver encodeObject:person1 forKey:@&quot;person1&quot;];</span><br><span class="line">[archiver encodeObject:person2 forKey:@&quot;person2&quot;];</span><br><span class="line">// 存档完毕(一定要调用这个方法)</span><br><span class="line">[archiver finishEncoding];</span><br><span class="line">// 将存档的数据写入文件</span><br><span class="line">[data writeToFile:path atomically:YES];</span><br></pre></td></tr></table></figure>
<p><em>Demo Code: 从归档文件中恢复对象</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 从文件中读取数据</span><br><span class="line">NSData *data = [NSData dataWithContentsOfFile:path];</span><br><span class="line">// 根据数据，解析成一个NSKeyedUnarchiver对象</span><br><span class="line">NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];</span><br><span class="line">Person *person1 = [unarchiver decodeObjectForKey:@&quot;person1&quot;];</span><br><span class="line">Person *person2 = [unarchiver decodeObjectForKey:@&quot;person2&quot;];</span><br><span class="line">// 恢复完毕</span><br><span class="line">[unarchiver finishDecoding];</span><br></pre></td></tr></table></figure>
<p>Copyright (c) 2016 Copyright Holder All Rights Reserved.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Objective-C学习小记]]></title>
      <url>http://lemtter.com/2014/07/02/Objective-C%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="Syntax-And-Notes"><a href="#Syntax-And-Notes" class="headerlink" title="Syntax And Notes"></a>Syntax And Notes</h2><h3 id="旧数组方法"><a href="#旧数组方法" class="headerlink" title="旧数组方法"></a>旧数组方法</h3><ul>
<li>在OC中数组除了可以用下标访问还可以用ObjectAtIndex:方法来访问,同样的创建数组也可以用旧方法arrayWithObjects:来访问。</li>
</ul>
<p><em>Demo Code</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*创建数组需以nil作为结束标记*/</span><br><span class="line">NSArray *anyArray = [NSArray arrayWithObjects:objectOne, ObjectTwo, nil];</span><br><span class="line">/*返回第一个对象＊/</span><br><span class="line">id object = [anyArray objectAtIndex:0];</span><br></pre></td></tr></table></figure>
<ul>
<li>创建数组可以向对象发送消息，也可以用字面量语法创建，但要注意用字面量创建数组不可包含nil对象不然会抛出异常。用发送消息的方式创建数组时会在遇到第一个nil时结束</li>
</ul>
<a id="more"></a>
<p><em>Demo Code</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">id objectOne = @&quot;xx&quot;;</span><br><span class="line">id objectTwo = nil;</span><br><span class="line">id objectThree = @&quot;oo&quot;;</span><br><span class="line"></span><br><span class="line">/*实际上anyArray所指的数组只包括objectOne，arrayWithObjects:会对传入的对象作检查,发现nil会认为数组创建到止结束*/</span><br><span class="line">NSArray *anyArray = [NSArray arrayWithObjects:objectOne, objectTwo, objectThree, nil];</span><br><span class="line">//用字面量创建数组会抛出异常，因为对象中不可包含nil</span><br><span class="line">NSArray *otherArray = @[objectOne, objectTwo, objectThree];</span><br></pre></td></tr></table></figure>
<h3 id="旧Dictionary方法"><a href="#旧Dictionary方法" class="headerlink" title="旧Dictionary方法"></a>旧Dictionary方法</h3><p>在OC引入下标前，使用setObject:forKey:方法来替代方括号来对’键－值’进行访问。字典是无序集合</p>
<p><em>Demo Code</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*定义一个可变字典*/</span><br><span class="line">NSMutableDictionary *dictionary = [[NSMutableDictionary alloc] init];</span><br><span class="line">/*用方法对指定键进行访问*/</span><br><span class="line">[dictionary setObject: anyObejct forKey: anyKey];</span><br></pre></td></tr></table></figure>
<h3 id="不可修改的对象（NSArray、NSString、NSData…）"><a href="#不可修改的对象（NSArray、NSString、NSData…）" class="headerlink" title="不可修改的对象（NSArray、NSString、NSData…）"></a>不可修改的对象（NSArray、NSString、NSData…）</h3><ul>
<li>不可修改对象的copy方法不会做任何其它操作，仅仅返回指向自己的指针</li>
<li>可修改(Mutable)对象(如：NSMutableArray,NSMutableString…)的copy方法会复制一份自己的拷贝</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li><p>子类不能访问父类通过@porperty生成的属性，但可以通过调用父类的get,set方法访问父类的属性</p>
<p><em>Demo code</em></p>
<p>   /<em> 在父类.h中定义一个属性 </em>/</p>
<p>   @property (nonatomic) NSMutableArray *array;</p>
<p>   /<em> 在子类中不能直接通过如下方法调用在父类中定义属性方法 </em>/</p>
<p>   [array addObject:@”xxxx”];</p>
<p>   /<em> 但是可以通过其生成的set，get方法来访问属性 </em>/</p>
<p>   [self.array addObject:@”xxxx”]</p>
</li>
</ul>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul>
<li>在@interface中定义的属性默认是保护(protect)的，在@implementation定义的属性默认是私有的</li>
<li>不在.h中声明的方法为私有方法</li>
<li>类工厂方法中用self来alloc,init对象</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>在分类中所声名的属性与方法都是私有的</li>
</ul>
<h3 id="instancetype-和-id-区别"><a href="#instancetype-和-id-区别" class="headerlink" title="instancetype 和 id 区别"></a>instancetype 和 id 区别</h3><blockquote>
<p>instancetype作方法返回值类型，编绎器会结合上下文作类型检查。如返回值的类型与所赋值的类型不一致会给出警告信息。id则不会作任何类型检查，但instancetype只能作为方法返回值类型，id则无此限制。</p>
</blockquote>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><ul>
<li>类方法可以直接访问类方法</li>
<li>类方法不可以直接调用对象方法</li>
<li>类方法不能访问成员变量</li>
</ul>
<h3 id="property-和-synthesize"><a href="#property-和-synthesize" class="headerlink" title="@property 和 @synthesize"></a>@property 和 @synthesize</h3><p>单独用@property生成实例变量或者属性时带’ <em> ‘而结合@synthesize时生动生成的实例变量或者属性不带’ </em> ‘</p>
<p><em>Demo Code</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//在.h中用@property声明一个实例变量</span><br><span class="line">@property int number;</span><br><span class="line">//在.m中用@synthesize实现set,get方法.此生成的是number变量，而不是_number</span><br><span class="line">@sythesize number;</span><br></pre></td></tr></table></figure>
<h3 id="Block-对象"><a href="#Block-对象" class="headerlink" title="Block 对象"></a>Block 对象</h3><blockquote>
<p>Block对象通会使用外部变量，对于基本变量Block会拷贝变量的值，并使用Block对象的局部变量保存。对于指针变量，Block对象会使用强引用。这意味着凡是Block对象用到的对象，都会被保留。所以在相应的Block对象被释放前，这些对象一定不会被释。这也是Block对象和函数的区别。</p>
</blockquote>
<h3 id="assign-VS-retain-and-copy"><a href="#assign-VS-retain-and-copy" class="headerlink" title="assign VS retain and copy"></a>assign VS retain and copy</h3><h4 id="assingn"><a href="#assingn" class="headerlink" title="assingn"></a>assingn</h4><ul>
<li>在用@property生成的set方法中，直接把变量赋值给属性</li>
</ul>
<p><em>Demo Code</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)setString:(NSString *)newString &#123;</span><br><span class="line">    _string = newString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h4><ul>
<li>在set方法中会relesae旧的属性并且retain新传进来的属性</li>
</ul>
<p><em>Demo Code</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(void)setString:(NSString *)newString &#123;</span><br><span class="line">    if (_string != newString) &#123;</span><br><span class="line">        [_string release];</span><br><span class="line">        _string = [newString retain];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><ul>
<li>在set方法中会拷贝一份原始对象赋值给将要set的值，这可以保证你在使用属性的时候不用担心它会被改变</li>
</ul>
<p><em>Demo Code</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(void)setString:(NSString *)newString &#123;</span><br><span class="line">    if (_string != newString) &#123;</span><br><span class="line">        [_string release];</span><br><span class="line">        _string = [newString copy];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果property是readonly的，在自定义的构造方法中强烈建议用如下方式写</li>
</ul>
<p><em>Demo code</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">initWithFirstName:(NSString *)string &#123;</span><br><span class="line">    if ( (self = [super init]) != nil ) &#123;</span><br><span class="line">        _lastName = [string copy];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KVC-and-KVO"><a href="#KVC-and-KVO" class="headerlink" title="KVC and KVO"></a>KVC and KVO</h3><ul>
<li>KVC只能传对象值，对于如像int,float等的类型可以通过转换为NSNumber对象</li>
</ul>
<p><em>Demo Code</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[object setValue:value forKey:key]</span><br></pre></td></tr></table></figure>
<h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><ul>
<li>单例需要重写allocWithZone:方法，因为alloc,new方法最终都会调用到allocWithZone:方法.</li>
<li>在单例模式下自定义的copyWithZone:与mutableCopyWithZone:都只需返回静态的object</li>
</ul>
<p><em>Demo Code</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static DemoClass *object = nil;</span><br><span class="line">+(instancetype)allocWithZone(struct _NSZone *)zone &#123;</span><br><span class="line"></span><br><span class="line">    /*  多线程访问时会有问题</span><br><span class="line">    if (object == nil) &#123;</span><br><span class="line">        object = [[super allocWithZone:zone] init];</span><br><span class="line">    &#125; */</span><br><span class="line">    // 多线程下的正确写法</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">                                object = [[super allocWithZone:zone] init];</span><br><span class="line">                               &#125;</span><br><span class="line">                 );</span><br><span class="line"></span><br><span class="line">    return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义的copy方法"><a href="#自定义的copy方法" class="headerlink" title="自定义的copy方法"></a>自定义的copy方法</h2><p>必让对象继承NSCopying和NSMutableCopying协议，实现协议中copyWithZone:与mutableCopying方法    </p>
<p><em>Demo Code</em>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">//这里用[self class]是因为在对象方法中无法获取到类对象，但能通过class方法可以返回类对象</span><br><span class="line">    DemoClass *object = [[[self class] allocWithZone:zone] init];</span><br><span class="line">    [object setProperty];</span><br><span class="line">    return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
  
  
</search>
